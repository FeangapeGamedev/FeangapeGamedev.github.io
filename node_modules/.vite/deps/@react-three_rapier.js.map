{
  "version": 3,
  "sources": ["../../@react-three/rapier/dist/react-three-rapier.esm.js"],
  "sourcesContent": ["import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\r\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\r\nimport { useFrame, useThree } from '@react-three/fiber';\r\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\r\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\r\nimport { suspend } from 'suspend-react';\r\nimport { mergeVertices } from 'three-stdlib';\r\n\r\nfunction _toPrimitive(t, r) {\r\n  if (\"object\" != typeof t || !t) return t;\r\n  var e = t[Symbol.toPrimitive];\r\n  if (void 0 !== e) {\r\n    var i = e.call(t, r || \"default\");\r\n    if (\"object\" != typeof i) return i;\r\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\r\n  }\r\n  return (\"string\" === r ? String : Number)(t);\r\n}\r\n\r\nfunction _toPropertyKey(t) {\r\n  var i = _toPrimitive(t, \"string\");\r\n  return \"symbol\" == typeof i ? i : i + \"\";\r\n}\r\n\r\nfunction _defineProperty(e, r, t) {\r\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\r\n    value: t,\r\n    enumerable: !0,\r\n    configurable: !0,\r\n    writable: !0\r\n  }) : e[r] = t, e;\r\n}\r\n\r\nfunction ownKeys(e, r) {\r\n  var t = Object.keys(e);\r\n  if (Object.getOwnPropertySymbols) {\r\n    var o = Object.getOwnPropertySymbols(e);\r\n    r && (o = o.filter(function (r) {\r\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\r\n    })), t.push.apply(t, o);\r\n  }\r\n  return t;\r\n}\r\nfunction _objectSpread2(e) {\r\n  for (var r = 1; r < arguments.length; r++) {\r\n    var t = null != arguments[r] ? arguments[r] : {};\r\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\r\n      _defineProperty(e, r, t[r]);\r\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\r\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\r\n    });\r\n  }\r\n  return e;\r\n}\r\n\r\nconst _quaternion = new Quaternion();\r\nnew Euler();\r\nconst _vector3 = new Vector3();\r\nnew Object3D();\r\nconst _matrix4 = new Matrix4();\r\nconst _position = new Vector3();\r\nconst _rotation = new Quaternion();\r\nconst _scale = new Vector3();\r\n\r\nconst vectorArrayToVector3 = arr => {\r\n  const [x, y, z] = arr;\r\n  return new Vector3(x, y, z);\r\n};\r\nconst rapierQuaternionToQuaternion = ({\r\n  x,\r\n  y,\r\n  z,\r\n  w\r\n}) => _quaternion.set(x, y, z, w);\r\nconst vector3ToRapierVector = v => {\r\n  if (Array.isArray(v)) {\r\n    return new Vector3$1(v[0], v[1], v[2]);\r\n  } else if (typeof v === \"number\") {\r\n    return new Vector3$1(v, v, v);\r\n  } else {\r\n    const threeVector3 = v;\r\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\r\n  }\r\n};\r\nconst quaternionToRapierQuaternion = v => {\r\n  if (Array.isArray(v)) {\r\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\r\n  } else {\r\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\r\n  }\r\n};\r\nconst rigidBodyTypeMap = {\r\n  fixed: 1,\r\n  dynamic: 0,\r\n  kinematicPosition: 2,\r\n  kinematicVelocity: 3\r\n};\r\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\r\nconst scaleVertices = (vertices, scale) => {\r\n  const scaledVerts = Array.from(vertices);\r\n  for (let i = 0; i < vertices.length / 3; i++) {\r\n    scaledVerts[i * 3] *= scale.x;\r\n    scaledVerts[i * 3 + 1] *= scale.y;\r\n    scaledVerts[i * 3 + 2] *= scale.z;\r\n  }\r\n  return scaledVerts;\r\n};\r\nconst vectorToTuple = v => {\r\n  if (!v) return [0];\r\n  if (v instanceof Quaternion) {\r\n    return [v.x, v.y, v.z, v.w];\r\n  }\r\n  if (v instanceof Vector3 || v instanceof Euler) {\r\n    return [v.x, v.y, v.z];\r\n  }\r\n  if (Array.isArray(v)) {\r\n    return v;\r\n  }\r\n  return [v];\r\n};\r\nfunction useConst(initialValue) {\r\n  const ref = useRef();\r\n  if (ref.current === undefined) {\r\n    ref.current = {\r\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\r\n    };\r\n  }\r\n  return ref.current.value;\r\n}\r\n\r\nconst useRaf = callback => {\r\n  const cb = useRef(callback);\r\n  const raf = useRef(0);\r\n  const lastFrame = useRef(0);\r\n  useEffect(() => {\r\n    cb.current = callback;\r\n  }, [callback]);\r\n  useEffect(() => {\r\n    const loop = () => {\r\n      const now = performance.now();\r\n      const delta = now - lastFrame.current;\r\n      raf.current = requestAnimationFrame(loop);\r\n      cb.current(delta / 1000);\r\n      lastFrame.current = now;\r\n    };\r\n    raf.current = requestAnimationFrame(loop);\r\n    return () => cancelAnimationFrame(raf.current);\r\n  }, []);\r\n};\r\n\r\nconst UseFrameStepper = ({\r\n  onStep,\r\n  updatePriority\r\n}) => {\r\n  useFrame((_, dt) => {\r\n    onStep(dt);\r\n  }, updatePriority);\r\n  return null;\r\n};\r\nconst RafStepper = ({\r\n  onStep\r\n}) => {\r\n  useRaf(dt => {\r\n    onStep(dt);\r\n  });\r\n  return null;\r\n};\r\nconst FrameStepper = ({\r\n  onStep,\r\n  type,\r\n  updatePriority\r\n}) => {\r\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\r\n    onStep: onStep\r\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\r\n    onStep: onStep,\r\n    updatePriority: updatePriority\r\n  });\r\n};\r\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\r\n\r\nfunction _objectWithoutPropertiesLoose(r, e) {\r\n  if (null == r) return {};\r\n  var t = {};\r\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\r\n    if (e.includes(n)) continue;\r\n    t[n] = r[n];\r\n  }\r\n  return t;\r\n}\r\n\r\nfunction _objectWithoutProperties(e, t) {\r\n  if (null == e) return {};\r\n  var o,\r\n    r,\r\n    i = _objectWithoutPropertiesLoose(e, t);\r\n  if (Object.getOwnPropertySymbols) {\r\n    var s = Object.getOwnPropertySymbols(e);\r\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\r\n  }\r\n  return i;\r\n}\r\n\r\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\"];\r\nconst scaleColliderArgs = (shape, args, scale) => {\r\n  const newArgs = args.slice();\r\n\r\n  // Heightfield uses a vector\r\n  if (shape === \"heightfield\") {\r\n    const s = newArgs[3];\r\n    s.x *= scale.x;\r\n    s.x *= scale.y;\r\n    s.x *= scale.z;\r\n    return newArgs;\r\n  }\r\n\r\n  // Trimesh and convex scale the vertices\r\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\r\n    newArgs[0] = scaleVertices(newArgs[0], scale);\r\n    return newArgs;\r\n  }\r\n\r\n  // Prepfill with some extra\r\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\r\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\r\n};\r\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\r\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\r\n  // @ts-ignore\r\n  const desc = ColliderDesc[options.shape](...scaledArgs);\r\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\r\n};\r\nconst immutableColliderOptions = [\"shape\", \"args\"];\r\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\r\nconst setColliderMassOptions = (collider, options) => {\r\n  if (options.density !== undefined) {\r\n    if (options.mass !== undefined || options.massProperties !== undefined) {\r\n      throw new Error(massPropertiesConflictError);\r\n    }\r\n    collider.setDensity(options.density);\r\n    return;\r\n  }\r\n  if (options.mass !== undefined) {\r\n    if (options.massProperties !== undefined) {\r\n      throw new Error(massPropertiesConflictError);\r\n    }\r\n    collider.setMass(options.mass);\r\n    return;\r\n  }\r\n  if (options.massProperties !== undefined) {\r\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\r\n  }\r\n};\r\nconst mutableColliderOptions = {\r\n  sensor: (collider, value) => {\r\n    collider.setSensor(value);\r\n  },\r\n  collisionGroups: (collider, value) => {\r\n    collider.setCollisionGroups(value);\r\n  },\r\n  solverGroups: (collider, value) => {\r\n    collider.setSolverGroups(value);\r\n  },\r\n  friction: (collider, value) => {\r\n    collider.setFriction(value);\r\n  },\r\n  frictionCombineRule: (collider, value) => {\r\n    collider.setFrictionCombineRule(value);\r\n  },\r\n  restitution: (collider, value) => {\r\n    collider.setRestitution(value);\r\n  },\r\n  restitutionCombineRule: (collider, value) => {\r\n    collider.setRestitutionCombineRule(value);\r\n  },\r\n  activeCollisionTypes: (collider, value) => {\r\n    collider.setActiveCollisionTypes(value);\r\n  },\r\n  contactSkin: (collider, value) => {\r\n    collider.setContactSkin(value);\r\n  },\r\n  // To make sure the options all mutable options are listed\r\n  quaternion: () => {},\r\n  position: () => {},\r\n  rotation: () => {},\r\n  scale: () => {}\r\n};\r\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\r\nconst setColliderOptions = (collider, options, states) => {\r\n  const state = states.get(collider.handle);\r\n  if (state) {\r\n    var _state$worldParent;\r\n    // Update collider position based on the object's position\r\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\r\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\r\n    state.object.updateWorldMatrix(true, false);\r\n    _matrix4.copy(state.object.matrixWorld);\r\n    if (parentInvertedWorldMatrix) {\r\n      _matrix4.premultiply(parentInvertedWorldMatrix);\r\n    }\r\n    _matrix4.decompose(_position, _rotation, _scale);\r\n    if (collider.parent()) {\r\n      collider.setTranslationWrtParent({\r\n        x: _position.x * parentWorldScale.x,\r\n        y: _position.y * parentWorldScale.y,\r\n        z: _position.z * parentWorldScale.z\r\n      });\r\n      collider.setRotationWrtParent(_rotation);\r\n    } else {\r\n      collider.setTranslation({\r\n        x: _position.x * parentWorldScale.x,\r\n        y: _position.y * parentWorldScale.y,\r\n        z: _position.z * parentWorldScale.z\r\n      });\r\n      collider.setRotation(_rotation);\r\n    }\r\n    mutableColliderOptionKeys.forEach(key => {\r\n      if (key in options) {\r\n        const option = options[key];\r\n        mutableColliderOptions[key](collider,\r\n        // @ts-ignore Option does not want to fit into the function, but it will\r\n        option, options);\r\n      }\r\n    });\r\n\r\n    // handle mass separately, because the assignments\r\n    // are exclusive.\r\n    setColliderMassOptions(collider, options);\r\n  }\r\n};\r\nconst useUpdateColliderOptions = (getCollider, props, states) => {\r\n  // TODO: Improve this, split each prop into its own effect\r\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\r\n    return vectorToTuple(props[key]);\r\n  }), [props]);\r\n  useEffect(() => {\r\n    const collider = getCollider();\r\n    setColliderOptions(collider, props, states);\r\n  }, [...mutablePropsAsFlatArray, getCollider]);\r\n};\r\nconst isChildOfMeshCollider = child => {\r\n  let flag = false;\r\n  child.traverseAncestors(a => {\r\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\r\n  });\r\n  return flag;\r\n};\r\nconst createColliderState = (collider, object, rigidBodyObject) => {\r\n  return {\r\n    collider,\r\n    worldParent: rigidBodyObject || undefined,\r\n    object\r\n  };\r\n};\r\nconst autoColliderMap = {\r\n  cuboid: \"cuboid\",\r\n  ball: \"ball\",\r\n  hull: \"convexHull\",\r\n  trimesh: \"trimesh\"\r\n};\r\nconst createColliderPropsFromChildren = ({\r\n  object,\r\n  ignoreMeshColliders: _ignoreMeshColliders = true,\r\n  options\r\n}) => {\r\n  const childColliderProps = [];\r\n  object.updateWorldMatrix(true, false);\r\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\r\n  const colliderFromChild = child => {\r\n    if (\"isMesh\" in child) {\r\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\r\n      const worldScale = child.getWorldScale(_scale);\r\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\r\n      child.updateWorldMatrix(true, false);\r\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\r\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\r\n      const {\r\n        geometry\r\n      } = child;\r\n      const {\r\n        args,\r\n        offset\r\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\r\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\r\n        args: args,\r\n        shape: shape,\r\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\r\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\r\n        scale: [worldScale.x, worldScale.y, worldScale.z]\r\n      });\r\n      childColliderProps.push(colliderProps);\r\n    }\r\n  };\r\n  if (options.includeInvisible) {\r\n    object.traverse(colliderFromChild);\r\n  } else {\r\n    object.traverseVisible(colliderFromChild);\r\n  }\r\n  return childColliderProps;\r\n};\r\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\r\n  switch (colliders) {\r\n    case \"cuboid\":\r\n      {\r\n        geometry.computeBoundingBox();\r\n        const {\r\n          boundingBox\r\n        } = geometry;\r\n        const size = boundingBox.getSize(new Vector3());\r\n        return {\r\n          args: [size.x / 2, size.y / 2, size.z / 2],\r\n          offset: boundingBox.getCenter(new Vector3())\r\n        };\r\n      }\r\n    case \"ball\":\r\n      {\r\n        geometry.computeBoundingSphere();\r\n        const {\r\n          boundingSphere\r\n        } = geometry;\r\n        const radius = boundingSphere.radius;\r\n        return {\r\n          args: [radius],\r\n          offset: boundingSphere.center\r\n        };\r\n      }\r\n    case \"trimesh\":\r\n      {\r\n        var _clonedGeometry$index;\r\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\r\n        return {\r\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\r\n          offset: new Vector3()\r\n        };\r\n      }\r\n    case \"hull\":\r\n      {\r\n        const g = geometry.clone();\r\n        return {\r\n          args: [g.attributes.position.array],\r\n          offset: new Vector3()\r\n        };\r\n      }\r\n  }\r\n  return {\r\n    args: [],\r\n    offset: new Vector3()\r\n  };\r\n};\r\nconst getActiveCollisionEventsFromProps = props => {\r\n  return {\r\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\r\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\r\n  };\r\n};\r\nconst useColliderEvents = (getCollider, props, events,\r\n/**\r\n * The RigidBody can pass down active events to the collider without attaching the event listners\r\n */\r\nactiveEvents = {}) => {\r\n  const {\r\n    onCollisionEnter,\r\n    onCollisionExit,\r\n    onIntersectionEnter,\r\n    onIntersectionExit,\r\n    onContactForce\r\n  } = props;\r\n  useEffect(() => {\r\n    const collider = getCollider();\r\n    if (collider) {\r\n      const {\r\n        collision: collisionEventsActive,\r\n        contactForce: contactForceEventsActive\r\n      } = getActiveCollisionEventsFromProps(props);\r\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\r\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\r\n      if (hasCollisionEvent && hasContactForceEvent) {\r\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\r\n      } else if (hasCollisionEvent) {\r\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\r\n      } else if (hasContactForceEvent) {\r\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\r\n      }\r\n      events.set(collider.handle, {\r\n        onCollisionEnter,\r\n        onCollisionExit,\r\n        onIntersectionEnter,\r\n        onIntersectionExit,\r\n        onContactForce\r\n      });\r\n    }\r\n    return () => {\r\n      if (collider) {\r\n        events.delete(collider.handle);\r\n      }\r\n    };\r\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\r\n};\r\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\r\n  const rest = _objectWithoutProperties(props, _excluded$2);\r\n  return rest;\r\n};\r\n\r\n// Utils\r\nconst useMutableCallback = fn => {\r\n  const ref = useRef(fn);\r\n  useEffect(() => {\r\n    ref.current = fn;\r\n  }, [fn]);\r\n  return ref;\r\n};\r\n\r\n// External hooks\r\n/**\r\n * Exposes the Rapier context, and world\r\n * @category Hooks\r\n */\r\nconst useRapier = () => {\r\n  const rapier = useContext(rapierContext);\r\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\r\n  return rapier;\r\n};\r\n\r\n/**\r\n * Registers a callback to be called before the physics step\r\n * @category Hooks\r\n */\r\nconst useBeforePhysicsStep = callback => {\r\n  const {\r\n    beforeStepCallbacks\r\n  } = useRapier();\r\n  const ref = useMutableCallback(callback);\r\n  useEffect(() => {\r\n    beforeStepCallbacks.add(ref);\r\n    return () => {\r\n      beforeStepCallbacks.delete(ref);\r\n    };\r\n  }, []);\r\n};\r\n\r\n/**\r\n * Registers a callback to be called after the physics step\r\n * @category Hooks\r\n */\r\nconst useAfterPhysicsStep = callback => {\r\n  const {\r\n    afterStepCallbacks\r\n  } = useRapier();\r\n  const ref = useMutableCallback(callback);\r\n  useEffect(() => {\r\n    afterStepCallbacks.add(ref);\r\n    return () => {\r\n      afterStepCallbacks.delete(ref);\r\n    };\r\n  }, []);\r\n};\r\n\r\n// Internal hooks\r\n/**\r\n * @internal\r\n */\r\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\r\n  const [colliderProps, setColliderProps] = useState([]);\r\n  useEffect(() => {\r\n    const object = ref.current;\r\n    if (object && options.colliders !== false) {\r\n      setColliderProps(createColliderPropsFromChildren({\r\n        object: ref.current,\r\n        options,\r\n        ignoreMeshColliders\r\n      }));\r\n    }\r\n  }, [options.colliders]);\r\n  return colliderProps;\r\n};\r\n\r\nconst Debug = /*#__PURE__*/memo(() => {\r\n  const {\r\n    world\r\n  } = useRapier();\r\n  const ref = useRef(null);\r\n  useFrame(() => {\r\n    const mesh = ref.current;\r\n    if (!mesh) return;\r\n    const buffers = world.debugRender();\r\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\r\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\r\n  });\r\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\r\n    ref: ref,\r\n    frustumCulled: false\r\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\r\n    color: 0xffffff,\r\n    vertexColors: true\r\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\r\n});\r\n\r\n/**\r\n * Creates a proxy that will create a singleton instance of the given class\r\n * when a property is accessed, and not before.\r\n *\r\n * @returns A proxy and a reset function, so that the instance can created again\r\n */\r\nconst createSingletonProxy = createInstance => {\r\n  let instance;\r\n  const handler = {\r\n    get(target, prop) {\r\n      if (!instance) {\r\n        instance = createInstance();\r\n      }\r\n      return Reflect.get(instance, prop);\r\n    },\r\n    set(target, prop, value) {\r\n      if (!instance) {\r\n        instance = createInstance();\r\n      }\r\n      return Reflect.set(instance, prop, value);\r\n    }\r\n  };\r\n  const proxy = new Proxy({}, handler);\r\n  const reset = () => {\r\n    instance = undefined;\r\n  };\r\n  const set = newInstance => {\r\n    instance = newInstance;\r\n  };\r\n\r\n  /**\r\n   * Return the proxy and a reset function\r\n   */\r\n  return {\r\n    proxy,\r\n    reset,\r\n    set\r\n  };\r\n};\r\n\r\nconst rapierContext = /*#__PURE__*/createContext(undefined);\r\nconst getCollisionPayloadFromSource = (target, other) => {\r\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\r\n  return {\r\n    target: {\r\n      rigidBody: target.rigidBody.object,\r\n      collider: target.collider.object,\r\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\r\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\r\n    },\r\n    other: {\r\n      rigidBody: other.rigidBody.object,\r\n      collider: other.collider.object,\r\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\r\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\r\n    },\r\n    rigidBody: other.rigidBody.object,\r\n    collider: other.collider.object,\r\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\r\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\r\n  };\r\n};\r\nconst importRapier = async () => {\r\n  let r = await import('@dimforge/rapier3d-compat');\r\n  await r.init();\r\n  return r;\r\n};\r\n/**\r\n * The main physics component used to create a physics world.\r\n * @category Components\r\n */\r\nconst Physics = props => {\r\n  const {\r\n    colliders = \"cuboid\",\r\n    children,\r\n    timeStep = 1 / 60,\r\n    paused = false,\r\n    interpolate = true,\r\n    updatePriority,\r\n    updateLoop = \"follow\",\r\n    debug = false,\r\n    gravity = [0, -9.81, 0],\r\n    allowedLinearError = 0.001,\r\n    predictionDistance = 0.002,\r\n    numSolverIterations = 4,\r\n    numAdditionalFrictionIterations = 4,\r\n    numInternalPgsIterations = 1,\r\n    minIslandSize = 128,\r\n    maxCcdSubsteps = 1,\r\n    contactNaturalFrequency = 30,\r\n    lengthUnit = 1\r\n  } = props;\r\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\r\n  const {\r\n    invalidate\r\n  } = useThree();\r\n  const rigidBodyStates = useConst(() => new Map());\r\n  const colliderStates = useConst(() => new Map());\r\n  const rigidBodyEvents = useConst(() => new Map());\r\n  const colliderEvents = useConst(() => new Map());\r\n  const eventQueue = useConst(() => new EventQueue(false));\r\n  const beforeStepCallbacks = useConst(() => new Set());\r\n  const afterStepCallbacks = useConst(() => new Set());\r\n\r\n  /**\r\n   * Initiate the world\r\n   * This creates a singleton proxy, so that the world is only created when\r\n   * something within it is accessed.\r\n   */\r\n  const {\r\n    proxy: worldProxy,\r\n    reset: resetWorldProxy,\r\n    set: setWorldProxy\r\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\r\n  useEffect(() => {\r\n    return () => {\r\n      worldProxy.free();\r\n      resetWorldProxy();\r\n    };\r\n  }, []);\r\n\r\n  // Update mutable props\r\n  useEffect(() => {\r\n    worldProxy.gravity = vector3ToRapierVector(gravity);\r\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\r\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\r\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\r\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\r\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\r\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\r\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\r\n    worldProxy.lengthUnit = lengthUnit;\r\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\r\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\r\n  const getSourceFromColliderHandle = useCallback(handle => {\r\n    var _collider$parent;\r\n    const collider = worldProxy.getCollider(handle);\r\n    const colEvents = colliderEvents.get(handle);\r\n    const colliderState = colliderStates.get(handle);\r\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\r\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\r\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\r\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\r\n    const source = {\r\n      collider: {\r\n        object: collider,\r\n        events: colEvents,\r\n        state: colliderState\r\n      },\r\n      rigidBody: {\r\n        object: rigidBody,\r\n        events: rbEvents,\r\n        state: rigidBodyState\r\n      }\r\n    };\r\n    return source;\r\n  }, []);\r\n  const [steppingState] = useState({\r\n    previousState: {},\r\n    accumulator: 0\r\n  });\r\n  const step = useCallback(dt => {\r\n    const world = worldProxy;\r\n\r\n    /* Check if the timestep is supposed to be variable. We'll do this here\r\n      once so we don't have to string-check every frame. */\r\n    const timeStepVariable = timeStep === \"vary\";\r\n\r\n    /**\r\n     * Fixed timeStep simulation progression\r\n     * @see https://gafferongames.com/post/fix_your_timestep/\r\n     */\r\n\r\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\r\n    const stepWorld = delta => {\r\n      // Trigger beforeStep callbacks\r\n      beforeStepCallbacks.forEach(callback => {\r\n        callback.current(world);\r\n      });\r\n      world.timestep = delta;\r\n      world.step(eventQueue);\r\n\r\n      // Trigger afterStep callbacks\r\n      afterStepCallbacks.forEach(callback => {\r\n        callback.current(world);\r\n      });\r\n    };\r\n    if (timeStepVariable) {\r\n      stepWorld(clampedDelta);\r\n    } else {\r\n      // don't step time forwards if paused\r\n      // Increase accumulator\r\n      steppingState.accumulator += clampedDelta;\r\n      while (steppingState.accumulator >= timeStep) {\r\n        // Set up previous state\r\n        // needed for accurate interpolations if the world steps more than once\r\n        if (interpolate) {\r\n          steppingState.previousState = {};\r\n          world.forEachRigidBody(body => {\r\n            steppingState.previousState[body.handle] = {\r\n              position: body.translation(),\r\n              rotation: body.rotation()\r\n            };\r\n          });\r\n        }\r\n        stepWorld(timeStep);\r\n        steppingState.accumulator -= timeStep;\r\n      }\r\n    }\r\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\r\n\r\n    // Update meshes\r\n    rigidBodyStates.forEach((state, handle) => {\r\n      const rigidBody = world.getRigidBody(handle);\r\n      const events = rigidBodyEvents.get(handle);\r\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\r\n        if (rigidBody.isSleeping() && !state.isSleeping) {\r\n          var _events$onSleep;\r\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\r\n        }\r\n        if (!rigidBody.isSleeping() && state.isSleeping) {\r\n          var _events$onWake;\r\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\r\n        }\r\n        state.isSleeping = rigidBody.isSleeping();\r\n      }\r\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\r\n        return;\r\n      }\r\n\r\n      // New states\r\n      let t = rigidBody.translation();\r\n      let r = rigidBody.rotation();\r\n      let previousState = steppingState.previousState[handle];\r\n      if (previousState) {\r\n        // Get previous simulated world position\r\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\r\n\r\n        // Apply previous tick position\r\n        if (state.meshType == \"mesh\") {\r\n          state.object.position.copy(_position);\r\n          state.object.quaternion.copy(_rotation);\r\n        }\r\n      }\r\n\r\n      // Get new position\r\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\r\n      if (state.meshType == \"instancedMesh\") {\r\n        state.setMatrix(_matrix4);\r\n      } else {\r\n        // Interpolate to new position\r\n        state.object.position.lerp(_position, interpolationAlpha);\r\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\r\n      }\r\n    });\r\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\r\n      const source1 = getSourceFromColliderHandle(handle1);\r\n      const source2 = getSourceFromColliderHandle(handle2);\r\n\r\n      // Collision Events\r\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\r\n        return;\r\n      }\r\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\r\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\r\n      if (started) {\r\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\r\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\r\n          /* RigidBody events */\r\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\r\n            manifold,\r\n            flipped\r\n          }));\r\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\r\n            manifold,\r\n            flipped\r\n          }));\r\n\r\n          /* Collider events */\r\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\r\n            manifold,\r\n            flipped\r\n          }));\r\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\r\n            manifold,\r\n            flipped\r\n          }));\r\n        });\r\n      } else {\r\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\r\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\r\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\r\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\r\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\r\n      }\r\n\r\n      // Sensor Intersections\r\n      if (started) {\r\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\r\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\r\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\r\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\r\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\r\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\r\n        }\r\n      } else {\r\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\r\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\r\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\r\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\r\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\r\n      }\r\n    });\r\n    eventQueue.drainContactForceEvents(event => {\r\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\r\n      const source1 = getSourceFromColliderHandle(event.collider1());\r\n      const source2 = getSourceFromColliderHandle(event.collider2());\r\n\r\n      // Collision Events\r\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\r\n        return;\r\n      }\r\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\r\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\r\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\r\n        totalForce: event.totalForce(),\r\n        totalForceMagnitude: event.totalForceMagnitude(),\r\n        maxForceDirection: event.maxForceDirection(),\r\n        maxForceMagnitude: event.maxForceMagnitude()\r\n      }));\r\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\r\n        totalForce: event.totalForce(),\r\n        totalForceMagnitude: event.totalForceMagnitude(),\r\n        maxForceDirection: event.maxForceDirection(),\r\n        maxForceMagnitude: event.maxForceMagnitude()\r\n      }));\r\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\r\n        totalForce: event.totalForce(),\r\n        totalForceMagnitude: event.totalForceMagnitude(),\r\n        maxForceDirection: event.maxForceDirection(),\r\n        maxForceMagnitude: event.maxForceMagnitude()\r\n      }));\r\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\r\n        totalForce: event.totalForce(),\r\n        totalForceMagnitude: event.totalForceMagnitude(),\r\n        maxForceDirection: event.maxForceDirection(),\r\n        maxForceMagnitude: event.maxForceMagnitude()\r\n      }));\r\n    });\r\n    world.forEachActiveRigidBody(() => {\r\n      invalidate();\r\n    });\r\n  }, [paused, timeStep, interpolate, worldProxy]);\r\n  const context = useMemo(() => ({\r\n    rapier,\r\n    world: worldProxy,\r\n    setWorld: world => {\r\n      setWorldProxy(world);\r\n    },\r\n    physicsOptions: {\r\n      colliders,\r\n      gravity\r\n    },\r\n    rigidBodyStates,\r\n    colliderStates,\r\n    rigidBodyEvents,\r\n    colliderEvents,\r\n    beforeStepCallbacks,\r\n    afterStepCallbacks,\r\n    isPaused: paused,\r\n    isDebug: debug,\r\n    step\r\n  }), [paused, step, debug, colliders, gravity]);\r\n  const stepCallback = useCallback(delta => {\r\n    if (!paused) {\r\n      step(delta);\r\n    }\r\n  }, [paused, step]);\r\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\r\n    value: context\r\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\r\n    onStep: stepCallback,\r\n    type: updateLoop,\r\n    updatePriority: updatePriority\r\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\r\n};\r\n\r\nfunction _extends() {\r\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\r\n    for (var e = 1; e < arguments.length; e++) {\r\n      var t = arguments[e];\r\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\r\n    }\r\n    return n;\r\n  }, _extends.apply(null, arguments);\r\n}\r\n\r\n/**\r\n * Initiate an instance and return a safe getter\r\n */\r\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\r\n  const ref = useRef();\r\n  const getInstance = useCallback(() => {\r\n    if (!ref.current) {\r\n      ref.current = createFn();\r\n    }\r\n    return ref.current;\r\n  }, dependencyList);\r\n  useEffect(() => {\r\n    // Save the destroy function and instance\r\n    const instance = getInstance();\r\n    const destroy = () => destroyFn(instance);\r\n    return () => {\r\n      destroy();\r\n      ref.current = undefined;\r\n    };\r\n  }, [getInstance]);\r\n  return getInstance;\r\n};\r\n\r\n/**\r\n * Takes an object resembling a Vector3 and returs a Three.Vector3\r\n * @category Math helpers\r\n */\r\nconst vec3 = ({\r\n  x,\r\n  y,\r\n  z\r\n} = {\r\n  x: 0,\r\n  y: 0,\r\n  z: 0\r\n}) => {\r\n  return new Vector3(x, y, z);\r\n};\r\n\r\n/**\r\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\r\n * @category Math helpers\r\n */\r\nconst quat = ({\r\n  x,\r\n  y,\r\n  z,\r\n  w\r\n} = {\r\n  x: 0,\r\n  y: 0,\r\n  z: 0,\r\n  w: 1\r\n}) => {\r\n  return new Quaternion(x, y, z, w);\r\n};\r\n\r\n/**\r\n * Takes an object resembling an Euler and returs a Three.Euler\r\n * @category Math helpers\r\n */\r\nconst euler = ({\r\n  x,\r\n  y,\r\n  z\r\n} = {\r\n  x: 0,\r\n  y: 0,\r\n  z: 0\r\n}) => {\r\n  return new Euler(x, y, z);\r\n};\r\n\r\n// Need to catch the case where forwardedRef is a function... how to do that?\r\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\r\n  const innerRef = useRef(defaultValue);\r\n\r\n  // Update the forwarded ref when the inner ref changes\r\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\r\n    if (!forwardedRef.current) {\r\n      forwardedRef.current = innerRef.current;\r\n    }\r\n    return forwardedRef;\r\n  }\r\n  return innerRef;\r\n};\r\n\r\n/**\r\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\r\n * @internal\r\n */\r\nconst AnyCollider = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\r\n  const {\r\n    children,\r\n    position,\r\n    rotation,\r\n    quaternion,\r\n    scale,\r\n    name\r\n  } = props;\r\n  const {\r\n    world,\r\n    colliderEvents,\r\n    colliderStates\r\n  } = useRapier();\r\n  const rigidBodyContext = useRigidBodyContext();\r\n  const colliderRef = useForwardedRef(forwardedRef);\r\n  const objectRef = useRef(null);\r\n\r\n  // We spread the props out here to make sure that the ref is updated when the props change.\r\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\r\n  const getInstance = useImperativeInstance(() => {\r\n    const worldScale = objectRef.current.getWorldScale(vec3());\r\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\r\n    if (typeof forwardedRef == \"function\") {\r\n      forwardedRef(collider);\r\n    }\r\n    colliderRef.current = collider;\r\n    return collider;\r\n  }, collider => {\r\n    if (world.getCollider(collider.handle)) {\r\n      world.removeCollider(collider, true);\r\n    }\r\n  }, [...immutablePropArray, rigidBodyContext]);\r\n  useEffect(() => {\r\n    const collider = getInstance();\r\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\r\n    return () => {\r\n      colliderStates.delete(collider.handle);\r\n    };\r\n  }, [getInstance]);\r\n  const mergedProps = useMemo(() => {\r\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\r\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\r\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\r\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\r\n  return /*#__PURE__*/React.createElement(\"object3D\", {\r\n    position: position,\r\n    rotation: rotation,\r\n    quaternion: quaternion,\r\n    scale: scale,\r\n    ref: objectRef,\r\n    name: name\r\n  }, children);\r\n}));\r\n/**\r\n * A cuboid collider shape\r\n * @category Colliders\r\n */\r\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\r\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n    shape: \"cuboid\",\r\n    ref: ref\r\n  }));\r\n});\r\nCuboidCollider.displayName = \"CuboidCollider\";\r\n/**\r\n * A round cuboid collider shape\r\n * @category Colliders\r\n */\r\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"roundCuboid\",\r\n  ref: ref\r\n})));\r\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\r\n/**\r\n * A ball collider shape\r\n * @category Colliders\r\n */\r\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"ball\",\r\n  ref: ref\r\n})));\r\nBallCollider.displayName = \"BallCollider\";\r\n/**\r\n * A capsule collider shape\r\n * @category Colliders\r\n */\r\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"capsule\",\r\n  ref: ref\r\n})));\r\nCapsuleCollider.displayName = \"CapsuleCollider\";\r\n/**\r\n * A heightfield collider shape\r\n * @category Colliders\r\n */\r\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"heightfield\",\r\n  ref: ref\r\n})));\r\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\r\n/**\r\n * A trimesh collider shape\r\n * @category Colliders\r\n */\r\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"trimesh\",\r\n  ref: ref\r\n})));\r\nTrimeshCollider.displayName = \"TrimeshCollider\";\r\n/**\r\n * A cone collider shape\r\n * @category Colliders\r\n */\r\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"cone\",\r\n  ref: ref\r\n})));\r\nConeCollider.displayName = \"ConeCollider\";\r\n/**\r\n * A round cylinder collider shape\r\n * @category Colliders\r\n */\r\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"roundCone\",\r\n  ref: ref\r\n})));\r\nRoundConeCollider.displayName = \"RoundConeCollider\";\r\n/**\r\n * A cylinder collider shape\r\n * @category Colliders\r\n */\r\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"cylinder\",\r\n  ref: ref\r\n})));\r\nCylinderCollider.displayName = \"CylinderCollider\";\r\n/**\r\n * A round cylinder collider shape\r\n * @category Colliders\r\n */\r\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"roundCylinder\",\r\n  ref: ref\r\n})));\r\nCylinderCollider.displayName = \"RoundCylinderCollider\";\r\n/**\r\n * A convex hull collider shape\r\n * @category Colliders\r\n */\r\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\r\n  shape: \"convexHull\",\r\n  ref: ref\r\n})));\r\nConvexHullCollider.displayName = \"ConvexHullCollider\";\r\n\r\nconst rigidBodyDescFromOptions = options => {\r\n  var _options$canSleep;\r\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\r\n  const desc = new RigidBodyDesc(type);\r\n\r\n  // Apply immutable options\r\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\r\n  return desc;\r\n};\r\nconst createRigidBodyState = ({\r\n  rigidBody,\r\n  object,\r\n  setMatrix,\r\n  getMatrix,\r\n  worldScale,\r\n  meshType: _meshType = \"mesh\"\r\n}) => {\r\n  object.updateWorldMatrix(true, false);\r\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\r\n  return {\r\n    object,\r\n    rigidBody,\r\n    invertedWorldMatrix,\r\n    setMatrix: setMatrix ? setMatrix : matrix => {\r\n      object.matrix.copy(matrix);\r\n    },\r\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\r\n    scale: worldScale || object.getWorldScale(_scale).clone(),\r\n    isSleeping: false,\r\n    meshType: _meshType\r\n  };\r\n};\r\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\r\nconst mutableRigidBodyOptions = {\r\n  gravityScale: (rb, value) => {\r\n    rb.setGravityScale(value, true);\r\n  },\r\n  additionalSolverIterations(rb, value) {\r\n    rb.setAdditionalSolverIterations(value);\r\n  },\r\n  linearDamping: (rb, value) => {\r\n    rb.setLinearDamping(value);\r\n  },\r\n  angularDamping: (rb, value) => {\r\n    rb.setAngularDamping(value);\r\n  },\r\n  dominanceGroup: (rb, value) => {\r\n    rb.setDominanceGroup(value);\r\n  },\r\n  enabledRotations: (rb, [x, y, z]) => {\r\n    rb.setEnabledRotations(x, y, z, true);\r\n  },\r\n  enabledTranslations: (rb, [x, y, z]) => {\r\n    rb.setEnabledTranslations(x, y, z, true);\r\n  },\r\n  lockRotations: (rb, value) => {\r\n    rb.lockRotations(value, true);\r\n  },\r\n  lockTranslations: (rb, value) => {\r\n    rb.lockTranslations(value, true);\r\n  },\r\n  angularVelocity: (rb, [x, y, z]) => {\r\n    rb.setAngvel({\r\n      x,\r\n      y,\r\n      z\r\n    }, true);\r\n  },\r\n  linearVelocity: (rb, [x, y, z]) => {\r\n    rb.setLinvel({\r\n      x,\r\n      y,\r\n      z\r\n    }, true);\r\n  },\r\n  ccd: (rb, value) => {\r\n    rb.enableCcd(value);\r\n  },\r\n  softCcdPrediction: (rb, value) => {\r\n    rb.setSoftCcdPrediction(value);\r\n  },\r\n  userData: (rb, value) => {\r\n    rb.userData = value;\r\n  },\r\n  type(rb, value) {\r\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\r\n  },\r\n  position: () => {},\r\n  rotation: () => {},\r\n  quaternion: () => {},\r\n  scale: () => {}\r\n};\r\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\r\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\r\n  if (!rigidBody) {\r\n    return;\r\n  }\r\n  const state = states.get(rigidBody.handle);\r\n  if (state) {\r\n    if (updateTranslations) {\r\n      state.object.updateWorldMatrix(true, false);\r\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\r\n      rigidBody.setTranslation(_position, false);\r\n      rigidBody.setRotation(_rotation, false);\r\n    }\r\n    mutableRigidBodyOptionKeys.forEach(key => {\r\n      if (key in options) {\r\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\r\n      }\r\n    });\r\n  }\r\n};\r\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\r\n  // TODO: Improve this, split each prop into its own effect\r\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\r\n    return vectorToTuple(props[key]);\r\n  }), [props]);\r\n  useEffect(() => {\r\n    const rigidBody = getRigidBody();\r\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\r\n  }, mutablePropsAsFlatArray);\r\n};\r\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\r\n  const {\r\n    onWake,\r\n    onSleep,\r\n    onCollisionEnter,\r\n    onCollisionExit,\r\n    onIntersectionEnter,\r\n    onIntersectionExit,\r\n    onContactForce\r\n  } = props;\r\n  const eventHandlers = {\r\n    onWake,\r\n    onSleep,\r\n    onCollisionEnter,\r\n    onCollisionExit,\r\n    onIntersectionEnter,\r\n    onIntersectionExit,\r\n    onContactForce\r\n  };\r\n  useEffect(() => {\r\n    const rigidBody = getRigidBody();\r\n    events.set(rigidBody.handle, eventHandlers);\r\n    return () => {\r\n      events.delete(rigidBody.handle);\r\n    };\r\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\r\n};\r\n\r\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\r\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\r\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\r\n/**\r\n * A rigid body is a physical object that can be simulated by the physics engine.\r\n * @category Components\r\n */\r\nconst RigidBody = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\r\n  const {\r\n      children,\r\n      type,\r\n      position,\r\n      rotation,\r\n      scale,\r\n      quaternion,\r\n      transformState\r\n    } = props,\r\n    objectProps = _objectWithoutProperties(props, _excluded$1);\r\n  const objectRef = useRef(null);\r\n  const rigidBodyRef = useForwardedRef(forwardedRef);\r\n  const {\r\n    world,\r\n    rigidBodyStates,\r\n    physicsOptions,\r\n    rigidBodyEvents\r\n  } = useRapier();\r\n  const mergedOptions = useMemo(() => {\r\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\r\n      children: undefined\r\n    });\r\n  }, [physicsOptions, props]);\r\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\r\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\r\n  });\r\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\r\n\r\n  // Provide a way to eagerly create rigidbody\r\n  const getRigidBody = useImperativeInstance(() => {\r\n    const desc = rigidBodyDescFromOptions(mergedOptions);\r\n    const rigidBody = world.createRigidBody(desc);\r\n    if (typeof forwardedRef === \"function\") {\r\n      forwardedRef(rigidBody);\r\n    }\r\n    rigidBodyRef.current = rigidBody;\r\n    return rigidBody;\r\n  }, rigidBody => {\r\n    if (world.getRigidBody(rigidBody.handle)) {\r\n      world.removeRigidBody(rigidBody);\r\n    }\r\n  }, immutablePropArray);\r\n\r\n  // Only provide a object state after the ref has been set\r\n  useEffect(() => {\r\n    const rigidBody = getRigidBody();\r\n    const state = createRigidBodyState({\r\n      rigidBody,\r\n      object: objectRef.current\r\n    });\r\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\r\n    return () => {\r\n      rigidBodyStates.delete(rigidBody.handle);\r\n    };\r\n  }, [getRigidBody]);\r\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\r\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\r\n  const contextValue = useMemo(() => {\r\n    return {\r\n      ref: objectRef,\r\n      getRigidBody: getRigidBody,\r\n      options: mergedOptions\r\n    };\r\n  }, [getRigidBody]);\r\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\r\n    value: contextValue\r\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\r\n    ref: objectRef\r\n  }, objectProps, {\r\n    position: position,\r\n    rotation: rotation,\r\n    quaternion: quaternion,\r\n    scale: scale\r\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\r\n    key: index\r\n  }, colliderProps)))));\r\n}));\r\nRigidBody.displayName = \"RigidBody\";\r\n\r\n/**\r\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\r\n * @category Colliders\r\n */\r\nconst MeshCollider = /*#__PURE__*/memo(props => {\r\n  const {\r\n    children,\r\n    type\r\n  } = props;\r\n  const {\r\n    physicsOptions\r\n  } = useRapier();\r\n  const object = useRef(null);\r\n  const {\r\n    options\r\n  } = useRigidBodyContext();\r\n  const mergedOptions = useMemo(() => {\r\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\r\n      children: undefined,\r\n      colliders: type\r\n    });\r\n  }, [physicsOptions, options]);\r\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\r\n  return /*#__PURE__*/React.createElement(\"object3D\", {\r\n    ref: object,\r\n    userData: {\r\n      r3RapierType: \"MeshCollider\"\r\n    }\r\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\r\n    key: index\r\n  }, colliderProps))));\r\n});\r\nMeshCollider.displayName = \"MeshCollider\";\r\n\r\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\r\nconst InstancedRigidBodies = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\r\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\r\n  const objectRef = useRef(null);\r\n  const instanceWrapperRef = useRef(null);\r\n  const {\r\n      // instanced props\r\n      children,\r\n      instances,\r\n      colliderNodes = [],\r\n      // wrapper object props\r\n      position,\r\n      rotation,\r\n      quaternion,\r\n      scale\r\n\r\n      // rigid body specific props, and r3f-object props\r\n    } = props,\r\n    rigidBodyProps = _objectWithoutProperties(props, _excluded);\r\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\r\n    children: undefined\r\n  }));\r\n  const getInstancedMesh = () => {\r\n    const firstChild = instanceWrapperRef.current.children[0];\r\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\r\n      return firstChild;\r\n    }\r\n    return undefined;\r\n  };\r\n  useEffect(() => {\r\n    const instancedMesh = getInstancedMesh();\r\n    if (instancedMesh) {\r\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\r\n    } else {\r\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\r\n    }\r\n  }, []);\r\n\r\n  // Update the RigidBodyStates whenever the instances change\r\n  const applyInstancedState = (state, index) => {\r\n    const instancedMesh = getInstancedMesh();\r\n    if (instancedMesh) {\r\n      return _objectSpread2(_objectSpread2({}, state), {}, {\r\n        getMatrix: matrix => {\r\n          instancedMesh.getMatrixAt(index, matrix);\r\n          return matrix;\r\n        },\r\n        setMatrix: matrix => {\r\n          instancedMesh.setMatrixAt(index, matrix);\r\n          instancedMesh.instanceMatrix.needsUpdate = true;\r\n        },\r\n        meshType: \"instancedMesh\"\r\n      });\r\n    }\r\n    return state;\r\n  };\r\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\r\n    ref: objectRef\r\n  }, rigidBodyProps, {\r\n    position: position,\r\n    rotation: rotation,\r\n    quaternion: quaternion,\r\n    scale: scale\r\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\r\n    ref: instanceWrapperRef\r\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\r\n    ref: body => rigidBodiesRef.current[index] = body,\r\n    transformState: state => applyInstancedState(state, index)\r\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\r\n    key: index\r\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\r\n    key: colliderIndex\r\n  }, colliderProps)))))));\r\n}));\r\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\r\n\r\n/**\r\n * @internal\r\n */\r\nconst useImpulseJoint = (body1, body2, params) => {\r\n  const {\r\n    world\r\n  } = useRapier();\r\n  const jointRef = useRef();\r\n  useImperativeInstance(() => {\r\n    if (body1.current && body2.current) {\r\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\r\n      jointRef.current = newJoint;\r\n      return newJoint;\r\n    }\r\n  }, joint => {\r\n    if (joint) {\r\n      jointRef.current = undefined;\r\n      if (world.getImpulseJoint(joint.handle)) {\r\n        world.removeImpulseJoint(joint, true);\r\n      }\r\n    }\r\n  }, []);\r\n  return jointRef;\r\n};\r\n\r\n/**\r\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\r\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\r\n * The fixed-joint makes these frames coincide in world-space.\r\n *\r\n * @category Hooks - Joints\r\n */\r\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\r\n  const {\r\n    rapier\r\n  } = useRapier();\r\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\r\n};\r\n\r\n/**\r\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\r\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\r\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\r\n * points that need to coincide on the local-space of each rigid-body.\r\n *\r\n * @category Hooks - Joints\r\n */\r\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\r\n  const {\r\n    rapier\r\n  } = useRapier();\r\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\r\n};\r\n\r\n/**\r\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\r\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\r\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\r\n *\r\n * @category Hooks - Joints\r\n */\r\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\r\n  const {\r\n    rapier\r\n  } = useRapier();\r\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\r\n  if (limits) {\r\n    params.limitsEnabled = true;\r\n    params.limits = limits;\r\n  }\r\n  return useImpulseJoint(body1, body2, params);\r\n};\r\n\r\n/**\r\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\r\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\r\n * local tangent axis can be specified for each rigid-body.\r\n *\r\n * @category Hooks - Joints\r\n */\r\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\r\n  const {\r\n    rapier\r\n  } = useRapier();\r\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\r\n  if (limits) {\r\n    params.limitsEnabled = true;\r\n    params.limits = limits;\r\n  }\r\n  return useImpulseJoint(body1, body2, params);\r\n};\r\n\r\n/**\r\n * The rope joint limits the max distance between two bodies.\r\n * @category Hooks - Joints\r\n */\r\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\r\n  const {\r\n    rapier\r\n  } = useRapier();\r\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\r\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\r\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\r\n  return useImpulseJoint(body1, body2, params);\r\n};\r\n\r\n/**\r\n * The spring joint applies a force proportional to the distance between two objects.\r\n * @category Hooks - Joints\r\n */\r\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\r\n  const {\r\n    rapier\r\n  } = useRapier();\r\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\r\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\r\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\r\n  return useImpulseJoint(body1, body2, params);\r\n};\r\n\r\n/**\r\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\r\n * properties of RigidBody or Collider components. The first argument represents a list of\r\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\r\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\r\n *\r\n * @example\r\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\r\n *\r\n * ```tsx\r\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\r\n * ```\r\n *\r\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\r\n *\r\n * ```tsx\r\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\r\n * ```\r\n *\r\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\r\n *\r\n * ```tsx\r\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\r\n * ```\r\n *\r\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\r\n * entities for collision events to trigger.\r\n *\r\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\r\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\r\n * @returns An InteractionGroup bitmask.\r\n */\r\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\r\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\r\n\r\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,mBAAgI;AAKhI,SAAS,aAAa,GAAG,GAAG;AAC1B,MAAI,YAAY,OAAO,KAAK,CAAC,EAAG,QAAO;AACvC,MAAI,IAAI,EAAE,OAAO,WAAW;AAC5B,MAAI,WAAW,GAAG;AAChB,QAAI,IAAI,EAAE,KAAK,GAAG,KAAK,SAAS;AAChC,QAAI,YAAY,OAAO,EAAG,QAAO;AACjC,UAAM,IAAI,UAAU,8CAA8C;AAAA,EACpE;AACA,UAAQ,aAAa,IAAI,SAAS,QAAQ,CAAC;AAC7C;AAEA,SAAS,eAAe,GAAG;AACzB,MAAI,IAAI,aAAa,GAAG,QAAQ;AAChC,SAAO,YAAY,OAAO,IAAI,IAAI,IAAI;AACxC;AAEA,SAAS,gBAAgB,GAAG,GAAG,GAAG;AAChC,UAAQ,IAAI,eAAe,CAAC,MAAM,IAAI,OAAO,eAAe,GAAG,GAAG;AAAA,IAChE,OAAO;AAAA,IACP,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,UAAU;AAAA,EACZ,CAAC,IAAI,EAAE,CAAC,IAAI,GAAG;AACjB;AAEA,SAAS,QAAQ,GAAG,GAAG;AACrB,MAAI,IAAI,OAAO,KAAK,CAAC;AACrB,MAAI,OAAO,uBAAuB;AAChC,QAAI,IAAI,OAAO,sBAAsB,CAAC;AACtC,UAAM,IAAI,EAAE,OAAO,SAAUA,IAAG;AAC9B,aAAO,OAAO,yBAAyB,GAAGA,EAAC,EAAE;AAAA,IAC/C,CAAC,IAAI,EAAE,KAAK,MAAM,GAAG,CAAC;AAAA,EACxB;AACA,SAAO;AACT;AACA,SAAS,eAAe,GAAG;AACzB,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,QAAI,IAAI,QAAQ,UAAU,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC;AAC/C,QAAI,IAAI,QAAQ,OAAO,CAAC,GAAG,IAAE,EAAE,QAAQ,SAAUA,IAAG;AAClD,sBAAgB,GAAGA,IAAG,EAAEA,EAAC,CAAC;AAAA,IAC5B,CAAC,IAAI,OAAO,4BAA4B,OAAO,iBAAiB,GAAG,OAAO,0BAA0B,CAAC,CAAC,IAAI,QAAQ,OAAO,CAAC,CAAC,EAAE,QAAQ,SAAUA,IAAG;AAChJ,aAAO,eAAe,GAAGA,IAAG,OAAO,yBAAyB,GAAGA,EAAC,CAAC;AAAA,IACnE,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAEA,IAAM,cAAc,IAAI,WAAW;AACnC,IAAI,MAAM;AACV,IAAM,WAAW,IAAI,QAAQ;AAC7B,IAAI,SAAS;AACb,IAAM,WAAW,IAAI,QAAQ;AAC7B,IAAM,YAAY,IAAI,QAAQ;AAC9B,IAAM,YAAY,IAAI,WAAW;AACjC,IAAM,SAAS,IAAI,QAAQ;AAE3B,IAAM,uBAAuB,SAAO;AAClC,QAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAClB,SAAO,IAAI,QAAQ,GAAG,GAAG,CAAC;AAC5B;AACA,IAAM,+BAA+B,CAAC;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM,YAAY,IAAI,GAAG,GAAG,GAAG,CAAC;AAChC,IAAM,wBAAwB,OAAK;AACjC,MAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,WAAO,IAAI,GAAU,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAAA,EACvC,WAAW,OAAO,MAAM,UAAU;AAChC,WAAO,IAAI,GAAU,GAAG,GAAG,CAAC;AAAA,EAC9B,OAAO;AACL,UAAM,eAAe;AACrB,WAAO,IAAI,GAAU,aAAa,GAAG,aAAa,GAAG,aAAa,CAAC;AAAA,EACrE;AACF;AACA,IAAM,+BAA+B,OAAK;AACxC,MAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,WAAO,IAAI,GAAa,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAAA,EAChD,OAAO;AACL,WAAO,IAAI,GAAa,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AAAA,EAC5C;AACF;AACA,IAAM,mBAAmB;AAAA,EACvB,OAAO;AAAA,EACP,SAAS;AAAA,EACT,mBAAmB;AAAA,EACnB,mBAAmB;AACrB;AACA,IAAM,0BAA0B,UAAQ,iBAAiB,IAAI;AAC7D,IAAM,gBAAgB,CAAC,UAAU,UAAU;AACzC,QAAM,cAAc,MAAM,KAAK,QAAQ;AACvC,WAAS,IAAI,GAAG,IAAI,SAAS,SAAS,GAAG,KAAK;AAC5C,gBAAY,IAAI,CAAC,KAAK,MAAM;AAC5B,gBAAY,IAAI,IAAI,CAAC,KAAK,MAAM;AAChC,gBAAY,IAAI,IAAI,CAAC,KAAK,MAAM;AAAA,EAClC;AACA,SAAO;AACT;AACA,IAAM,gBAAgB,OAAK;AACzB,MAAI,CAAC,EAAG,QAAO,CAAC,CAAC;AACjB,MAAI,aAAa,YAAY;AAC3B,WAAO,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AAAA,EAC5B;AACA,MAAI,aAAa,WAAW,aAAa,OAAO;AAC9C,WAAO,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AAAA,EACvB;AACA,MAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,WAAO;AAAA,EACT;AACA,SAAO,CAAC,CAAC;AACX;AACA,SAAS,SAAS,cAAc;AAC9B,QAAM,UAAM,qBAAO;AACnB,MAAI,IAAI,YAAY,QAAW;AAC7B,QAAI,UAAU;AAAA,MACZ,OAAO,OAAO,iBAAiB,aAAa,aAAa,IAAI;AAAA,IAC/D;AAAA,EACF;AACA,SAAO,IAAI,QAAQ;AACrB;AAEA,IAAM,SAAS,cAAY;AACzB,QAAM,SAAK,qBAAO,QAAQ;AAC1B,QAAM,UAAM,qBAAO,CAAC;AACpB,QAAM,gBAAY,qBAAO,CAAC;AAC1B,8BAAU,MAAM;AACd,OAAG,UAAU;AAAA,EACf,GAAG,CAAC,QAAQ,CAAC;AACb,8BAAU,MAAM;AACd,UAAM,OAAO,MAAM;AACjB,YAAM,MAAM,YAAY,IAAI;AAC5B,YAAM,QAAQ,MAAM,UAAU;AAC9B,UAAI,UAAU,sBAAsB,IAAI;AACxC,SAAG,QAAQ,QAAQ,GAAI;AACvB,gBAAU,UAAU;AAAA,IACtB;AACA,QAAI,UAAU,sBAAsB,IAAI;AACxC,WAAO,MAAM,qBAAqB,IAAI,OAAO;AAAA,EAC/C,GAAG,CAAC,CAAC;AACP;AAEA,IAAM,kBAAkB,CAAC;AAAA,EACvB;AAAA,EACA;AACF,MAAM;AACJ,WAAS,CAAC,GAAG,OAAO;AAClB,WAAO,EAAE;AAAA,EACX,GAAG,cAAc;AACjB,SAAO;AACT;AACA,IAAM,aAAa,CAAC;AAAA,EAClB;AACF,MAAM;AACJ,SAAO,QAAM;AACX,WAAO,EAAE;AAAA,EACX,CAAC;AACD,SAAO;AACT;AACA,IAAM,eAAe,CAAC;AAAA,EACpB;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,SAAO,SAAS,gBAA6B,aAAAC,QAAM,cAAc,YAAY;AAAA,IAC3E;AAAA,EACF,CAAC,IAAiB,aAAAA,QAAM,cAAc,iBAAiB;AAAA,IACrD;AAAA,IACA;AAAA,EACF,CAAC;AACH;AACA,IAAI,qBAA8B,mBAAK,YAAY;AAEnD,SAAS,8BAA8B,GAAG,GAAG;AAC3C,MAAI,QAAQ,EAAG,QAAO,CAAC;AACvB,MAAI,IAAI,CAAC;AACT,WAAS,KAAK,EAAG,KAAI,CAAC,EAAE,eAAe,KAAK,GAAG,CAAC,GAAG;AACjD,QAAI,EAAE,SAAS,CAAC,EAAG;AACnB,MAAE,CAAC,IAAI,EAAE,CAAC;AAAA,EACZ;AACA,SAAO;AACT;AAEA,SAAS,yBAAyB,GAAG,GAAG;AACtC,MAAI,QAAQ,EAAG,QAAO,CAAC;AACvB,MAAI,GACF,GACA,IAAI,8BAA8B,GAAG,CAAC;AACxC,MAAI,OAAO,uBAAuB;AAChC,QAAI,IAAI,OAAO,sBAAsB,CAAC;AACtC,SAAK,IAAI,GAAG,IAAI,EAAE,QAAQ,IAAK,KAAI,EAAE,CAAC,GAAG,EAAE,SAAS,CAAC,KAAK,CAAC,EAAE,qBAAqB,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,EAC7G;AACA,SAAO;AACT;AAEA,IAAM,cAAc,CAAC,QAAQ,iBAAiB,kBAAkB,QAAQ,oBAAoB,mBAAmB,uBAAuB,sBAAsB,kBAAkB,YAAY,YAAY,OAAO,gBAAgB,mBAAmB;AAChP,IAAM,oBAAoB,CAAC,OAAO,MAAM,UAAU;AAChD,QAAM,UAAU,KAAK,MAAM;AAG3B,MAAI,UAAU,eAAe;AAC3B,UAAM,IAAI,QAAQ,CAAC;AACnB,MAAE,KAAK,MAAM;AACb,MAAE,KAAK,MAAM;AACb,MAAE,KAAK,MAAM;AACb,WAAO;AAAA,EACT;AAGA,MAAI,UAAU,aAAa,UAAU,cAAc;AACjD,YAAQ,CAAC,IAAI,cAAc,QAAQ,CAAC,GAAG,KAAK;AAC5C,WAAO;AAAA,EACT;AAGA,QAAM,aAAa,CAAC,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;AAC/D,SAAO,QAAQ,IAAI,CAAC,KAAK,UAAU,WAAW,KAAK,IAAI,GAAG;AAC5D;AACA,IAAM,4BAA4B,CAAC,SAAS,OAAO,OAAO,iBAAiB;AACzE,QAAM,aAAa,kBAAkB,QAAQ,OAAO,QAAQ,MAAM,KAAK;AAEvE,QAAM,OAAO,GAAa,QAAQ,KAAK,EAAE,GAAG,UAAU;AACtD,SAAO,MAAM,eAAe,MAAM,iBAAiB,QAAQ,iBAAiB,SAAS,SAAS,aAAa,CAAC;AAC9G;AACA,IAAM,2BAA2B,CAAC,SAAS,MAAM;AACjD,IAAM,8BAA8B;AACpC,IAAM,yBAAyB,CAAC,UAAU,YAAY;AACpD,MAAI,QAAQ,YAAY,QAAW;AACjC,QAAI,QAAQ,SAAS,UAAa,QAAQ,mBAAmB,QAAW;AACtE,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,aAAS,WAAW,QAAQ,OAAO;AACnC;AAAA,EACF;AACA,MAAI,QAAQ,SAAS,QAAW;AAC9B,QAAI,QAAQ,mBAAmB,QAAW;AACxC,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,aAAS,QAAQ,QAAQ,IAAI;AAC7B;AAAA,EACF;AACA,MAAI,QAAQ,mBAAmB,QAAW;AACxC,aAAS,kBAAkB,QAAQ,eAAe,MAAM,QAAQ,eAAe,cAAc,QAAQ,eAAe,yBAAyB,QAAQ,eAAe,wBAAwB;AAAA,EAC9L;AACF;AACA,IAAM,yBAAyB;AAAA,EAC7B,QAAQ,CAAC,UAAU,UAAU;AAC3B,aAAS,UAAU,KAAK;AAAA,EAC1B;AAAA,EACA,iBAAiB,CAAC,UAAU,UAAU;AACpC,aAAS,mBAAmB,KAAK;AAAA,EACnC;AAAA,EACA,cAAc,CAAC,UAAU,UAAU;AACjC,aAAS,gBAAgB,KAAK;AAAA,EAChC;AAAA,EACA,UAAU,CAAC,UAAU,UAAU;AAC7B,aAAS,YAAY,KAAK;AAAA,EAC5B;AAAA,EACA,qBAAqB,CAAC,UAAU,UAAU;AACxC,aAAS,uBAAuB,KAAK;AAAA,EACvC;AAAA,EACA,aAAa,CAAC,UAAU,UAAU;AAChC,aAAS,eAAe,KAAK;AAAA,EAC/B;AAAA,EACA,wBAAwB,CAAC,UAAU,UAAU;AAC3C,aAAS,0BAA0B,KAAK;AAAA,EAC1C;AAAA,EACA,sBAAsB,CAAC,UAAU,UAAU;AACzC,aAAS,wBAAwB,KAAK;AAAA,EACxC;AAAA,EACA,aAAa,CAAC,UAAU,UAAU;AAChC,aAAS,eAAe,KAAK;AAAA,EAC/B;AAAA;AAAA,EAEA,YAAY,MAAM;AAAA,EAAC;AAAA,EACnB,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,OAAO,MAAM;AAAA,EAAC;AAChB;AACA,IAAM,4BAA4B,OAAO,KAAK,sBAAsB;AACpE,IAAM,qBAAqB,CAAC,UAAU,SAAS,WAAW;AACxD,QAAM,QAAQ,OAAO,IAAI,SAAS,MAAM;AACxC,MAAI,OAAO;AACT,QAAI;AAEJ,UAAM,mBAAmB,MAAM,OAAO,OAAO,cAAc,QAAQ;AACnE,UAAM,6BAA6B,qBAAqB,MAAM,iBAAiB,QAAQ,uBAAuB,SAAS,SAAS,mBAAmB,YAAY,MAAM,EAAE,OAAO;AAC9K,UAAM,OAAO,kBAAkB,MAAM,KAAK;AAC1C,aAAS,KAAK,MAAM,OAAO,WAAW;AACtC,QAAI,2BAA2B;AAC7B,eAAS,YAAY,yBAAyB;AAAA,IAChD;AACA,aAAS,UAAU,WAAW,WAAW,MAAM;AAC/C,QAAI,SAAS,OAAO,GAAG;AACrB,eAAS,wBAAwB;AAAA,QAC/B,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,MACpC,CAAC;AACD,eAAS,qBAAqB,SAAS;AAAA,IACzC,OAAO;AACL,eAAS,eAAe;AAAA,QACtB,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,MACpC,CAAC;AACD,eAAS,YAAY,SAAS;AAAA,IAChC;AACA,8BAA0B,QAAQ,SAAO;AACvC,UAAI,OAAO,SAAS;AAClB,cAAM,SAAS,QAAQ,GAAG;AAC1B,+BAAuB,GAAG;AAAA,UAAE;AAAA;AAAA,UAE5B;AAAA,UAAQ;AAAA,QAAO;AAAA,MACjB;AAAA,IACF,CAAC;AAID,2BAAuB,UAAU,OAAO;AAAA,EAC1C;AACF;AACA,IAAM,2BAA2B,CAAC,aAAa,OAAO,WAAW;AAE/D,QAAM,8BAA0B,sBAAQ,MAAM,0BAA0B,QAAQ,SAAO;AACrF,WAAO,cAAc,MAAM,GAAG,CAAC;AAAA,EACjC,CAAC,GAAG,CAAC,KAAK,CAAC;AACX,8BAAU,MAAM;AACd,UAAM,WAAW,YAAY;AAC7B,uBAAmB,UAAU,OAAO,MAAM;AAAA,EAC5C,GAAG,CAAC,GAAG,yBAAyB,WAAW,CAAC;AAC9C;AACA,IAAM,wBAAwB,WAAS;AACrC,MAAI,OAAO;AACX,QAAM,kBAAkB,OAAK;AAC3B,QAAI,EAAE,SAAS,iBAAiB,eAAgB,QAAO;AAAA,EACzD,CAAC;AACD,SAAO;AACT;AACA,IAAM,sBAAsB,CAAC,UAAU,QAAQ,oBAAoB;AACjE,SAAO;AAAA,IACL;AAAA,IACA,aAAa,mBAAmB;AAAA,IAChC;AAAA,EACF;AACF;AACA,IAAM,kBAAkB;AAAA,EACtB,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AACX;AACA,IAAM,kCAAkC,CAAC;AAAA,EACvC;AAAA,EACA,qBAAqB,uBAAuB;AAAA,EAC5C;AACF,MAAM;AACJ,QAAM,qBAAqB,CAAC;AAC5B,SAAO,kBAAkB,MAAM,KAAK;AACpC,QAAM,4BAA4B,OAAO,YAAY,MAAM,EAAE,OAAO;AACpE,QAAM,oBAAoB,WAAS;AACjC,QAAI,YAAY,OAAO;AACrB,UAAI,wBAAwB,sBAAsB,KAAK,EAAG;AAC1D,YAAM,aAAa,MAAM,cAAc,MAAM;AAC7C,YAAM,QAAQ,gBAAgB,QAAQ,aAAa,QAAQ;AAC3D,YAAM,kBAAkB,MAAM,KAAK;AACnC,eAAS,KAAK,MAAM,WAAW,EAAE,YAAY,yBAAyB,EAAE,UAAU,WAAW,WAAW,MAAM;AAC9G,YAAM,gBAAgB,IAAI,MAAM,EAAE,kBAAkB,WAAW,KAAK;AACpE,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,MACF,IAAI,4BAA4B,UAAU,QAAQ,aAAa,QAAQ;AACvE,YAAM,gBAAgB,eAAe,eAAe,CAAC,GAAG,+BAA+B,OAAO,CAAC,GAAG,CAAC,GAAG;AAAA,QACpG;AAAA,QACA;AAAA,QACA,UAAU,CAAC,cAAc,GAAG,cAAc,GAAG,cAAc,CAAC;AAAA,QAC5D,UAAU,CAAC,UAAU,IAAI,OAAO,IAAI,WAAW,GAAG,UAAU,IAAI,OAAO,IAAI,WAAW,GAAG,UAAU,IAAI,OAAO,IAAI,WAAW,CAAC;AAAA,QAC9H,OAAO,CAAC,WAAW,GAAG,WAAW,GAAG,WAAW,CAAC;AAAA,MAClD,CAAC;AACD,yBAAmB,KAAK,aAAa;AAAA,IACvC;AAAA,EACF;AACA,MAAI,QAAQ,kBAAkB;AAC5B,WAAO,SAAS,iBAAiB;AAAA,EACnC,OAAO;AACL,WAAO,gBAAgB,iBAAiB;AAAA,EAC1C;AACA,SAAO;AACT;AACA,IAAM,8BAA8B,CAAC,UAAU,cAAc;AAC3D,UAAQ,WAAW;AAAA,IACjB,KAAK,UACH;AACE,eAAS,mBAAmB;AAC5B,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,YAAM,OAAO,YAAY,QAAQ,IAAI,QAAQ,CAAC;AAC9C,aAAO;AAAA,QACL,MAAM,CAAC,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC;AAAA,QACzC,QAAQ,YAAY,UAAU,IAAI,QAAQ,CAAC;AAAA,MAC7C;AAAA,IACF;AAAA,IACF,KAAK,QACH;AACE,eAAS,sBAAsB;AAC/B,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,YAAM,SAAS,eAAe;AAC9B,aAAO;AAAA,QACL,MAAM,CAAC,MAAM;AAAA,QACb,QAAQ,eAAe;AAAA,MACzB;AAAA,IACF;AAAA,IACF,KAAK,WACH;AACE,UAAI;AACJ,YAAM,iBAAiB,SAAS,QAAQ,SAAS,MAAM,IAAI,cAAc,QAAQ;AACjF,aAAO;AAAA,QACL,MAAM,CAAC,eAAe,WAAW,SAAS,QAAQ,wBAAwB,eAAe,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB,KAAK;AAAA,QACnL,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,IACF;AAAA,IACF,KAAK,QACH;AACE,YAAM,IAAI,SAAS,MAAM;AACzB,aAAO;AAAA,QACL,MAAM,CAAC,EAAE,WAAW,SAAS,KAAK;AAAA,QAClC,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,IACF;AAAA,EACJ;AACA,SAAO;AAAA,IACL,MAAM,CAAC;AAAA,IACP,QAAQ,IAAI,QAAQ;AAAA,EACtB;AACF;AACA,IAAM,oCAAoC,WAAS;AACjD,SAAO;AAAA,IACL,WAAW,CAAC,EAAE,UAAU,QAAQ,UAAU,UAAU,MAAM,oBAAoB,UAAU,QAAQ,UAAU,UAAU,MAAM,mBAAmB,UAAU,QAAQ,UAAU,UAAU,MAAM,uBAAuB,UAAU,QAAQ,UAAU,UAAU,MAAM;AAAA,IAC5P,cAAc,CAAC,EAAE,UAAU,QAAQ,UAAU,UAAU,MAAM;AAAA,EAC/D;AACF;AACA,IAAM,oBAAoB,CAAC,aAAa,OAAO,QAI/C,eAAe,CAAC,MAAM;AACpB,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,8BAAU,MAAM;AACd,UAAM,WAAW,YAAY;AAC7B,QAAI,UAAU;AACZ,YAAM;AAAA,QACJ,WAAW;AAAA,QACX,cAAc;AAAA,MAChB,IAAI,kCAAkC,KAAK;AAC3C,YAAM,oBAAoB,yBAAyB,aAAa;AAChE,YAAM,uBAAuB,4BAA4B,aAAa;AACtE,UAAI,qBAAqB,sBAAsB;AAC7C,iBAAS,gBAAgB,GAAa,mBAAmB,GAAa,oBAAoB;AAAA,MAC5F,WAAW,mBAAmB;AAC5B,iBAAS,gBAAgB,GAAa,gBAAgB;AAAA,MACxD,WAAW,sBAAsB;AAC/B,iBAAS,gBAAgB,GAAa,oBAAoB;AAAA,MAC5D;AACA,aAAO,IAAI,SAAS,QAAQ;AAAA,QAC1B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AACA,WAAO,MAAM;AACX,UAAI,UAAU;AACZ,eAAO,OAAO,SAAS,MAAM;AAAA,MAC/B;AAAA,IACF;AAAA,EACF,GAAG,CAAC,kBAAkB,iBAAiB,qBAAqB,oBAAoB,gBAAgB,YAAY,CAAC;AAC/G;AACA,IAAM,iCAAiC,CAAC,QAAQ,CAAC,MAAM;AACrD,QAAM,OAAO,yBAAyB,OAAO,WAAW;AACxD,SAAO;AACT;AAGA,IAAM,qBAAqB,QAAM;AAC/B,QAAM,UAAM,qBAAO,EAAE;AACrB,8BAAU,MAAM;AACd,QAAI,UAAU;AAAA,EAChB,GAAG,CAAC,EAAE,CAAC;AACP,SAAO;AACT;AAOA,IAAM,YAAY,MAAM;AACtB,QAAM,aAAS,yBAAW,aAAa;AACvC,MAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,gEAAgE;AAC7F,SAAO;AACT;AAMA,IAAM,uBAAuB,cAAY;AACvC,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,MAAM,mBAAmB,QAAQ;AACvC,8BAAU,MAAM;AACd,wBAAoB,IAAI,GAAG;AAC3B,WAAO,MAAM;AACX,0BAAoB,OAAO,GAAG;AAAA,IAChC;AAAA,EACF,GAAG,CAAC,CAAC;AACP;AAMA,IAAM,sBAAsB,cAAY;AACtC,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,MAAM,mBAAmB,QAAQ;AACvC,8BAAU,MAAM;AACd,uBAAmB,IAAI,GAAG;AAC1B,WAAO,MAAM;AACX,yBAAmB,OAAO,GAAG;AAAA,IAC/B;AAAA,EACF,GAAG,CAAC,CAAC;AACP;AAMA,IAAM,wBAAwB,CAAC,KAAK,SAAS,sBAAsB,SAAS;AAC1E,QAAM,CAAC,eAAe,gBAAgB,QAAI,uBAAS,CAAC,CAAC;AACrD,8BAAU,MAAM;AACd,UAAM,SAAS,IAAI;AACnB,QAAI,UAAU,QAAQ,cAAc,OAAO;AACzC,uBAAiB,gCAAgC;AAAA,QAC/C,QAAQ,IAAI;AAAA,QACZ;AAAA,QACA;AAAA,MACF,CAAC,CAAC;AAAA,IACJ;AAAA,EACF,GAAG,CAAC,QAAQ,SAAS,CAAC;AACtB,SAAO;AACT;AAEA,IAAM,YAAqB,mBAAK,MAAM;AACpC,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,UAAM,qBAAO,IAAI;AACvB,WAAS,MAAM;AACb,UAAM,OAAO,IAAI;AACjB,QAAI,CAAC,KAAM;AACX,UAAM,UAAU,MAAM,YAAY;AAClC,SAAK,SAAS,aAAa,YAAY,IAAI,gBAAgB,QAAQ,UAAU,CAAC,CAAC;AAC/E,SAAK,SAAS,aAAa,SAAS,IAAI,gBAAgB,QAAQ,QAAQ,CAAC,CAAC;AAAA,EAC5E,CAAC;AACD,SAAoB,aAAAA,QAAM,cAAc,SAAS,MAAmB,aAAAA,QAAM,cAAc,gBAAgB;AAAA,IACtG;AAAA,IACA,eAAe;AAAA,EACjB,GAAgB,aAAAA,QAAM,cAAc,qBAAqB;AAAA,IACvD,OAAO;AAAA,IACP,cAAc;AAAA,EAChB,CAAC,GAAgB,aAAAA,QAAM,cAAc,kBAAkB,IAAI,CAAC,CAAC;AAC/D,CAAC;AAQD,IAAM,uBAAuB,oBAAkB;AAC7C,MAAI;AACJ,QAAM,UAAU;AAAA,IACd,IAAI,QAAQ,MAAM;AAChB,UAAI,CAAC,UAAU;AACb,mBAAW,eAAe;AAAA,MAC5B;AACA,aAAO,QAAQ,IAAI,UAAU,IAAI;AAAA,IACnC;AAAA,IACA,IAAI,QAAQ,MAAM,OAAO;AACvB,UAAI,CAAC,UAAU;AACb,mBAAW,eAAe;AAAA,MAC5B;AACA,aAAO,QAAQ,IAAI,UAAU,MAAM,KAAK;AAAA,IAC1C;AAAA,EACF;AACA,QAAM,QAAQ,IAAI,MAAM,CAAC,GAAG,OAAO;AACnC,QAAM,QAAQ,MAAM;AAClB,eAAW;AAAA,EACb;AACA,QAAM,MAAM,iBAAe;AACzB,eAAW;AAAA,EACb;AAKA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,oBAA6B,4BAAc,MAAS;AAC1D,IAAM,gCAAgC,CAAC,QAAQ,UAAU;AACvD,MAAI,uBAAuB,uBAAuB,uBAAuB,uBAAuB,wBAAwB;AACxH,SAAO;AAAA,IACL,QAAQ;AAAA,MACN,WAAW,OAAO,UAAU;AAAA,MAC5B,UAAU,OAAO,SAAS;AAAA,MAC1B,iBAAiB,wBAAwB,OAAO,SAAS,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,MAC9I,kBAAkB,wBAAwB,OAAO,UAAU,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,IAClJ;AAAA,IACA,OAAO;AAAA,MACL,WAAW,MAAM,UAAU;AAAA,MAC3B,UAAU,MAAM,SAAS;AAAA,MACzB,iBAAiB,wBAAwB,MAAM,SAAS,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,MAC7I,kBAAkB,wBAAwB,MAAM,UAAU,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,IACjJ;AAAA,IACA,WAAW,MAAM,UAAU;AAAA,IAC3B,UAAU,MAAM,SAAS;AAAA,IACzB,iBAAiB,yBAAyB,MAAM,SAAS,WAAW,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB;AAAA,IAChJ,kBAAkB,yBAAyB,MAAM,UAAU,WAAW,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB;AAAA,EACpJ;AACF;AACA,IAAM,eAAe,YAAY;AAC/B,MAAI,IAAI,MAAM,OAAO,yBAA2B;AAChD,QAAM,EAAE,KAAK;AACb,SAAO;AACT;AAKA,IAAM,UAAU,WAAS;AACvB,QAAM;AAAA,IACJ,YAAY;AAAA,IACZ;AAAA,IACA,WAAW,IAAI;AAAA,IACf,SAAS;AAAA,IACT,cAAc;AAAA,IACd;AAAA,IACA,aAAa;AAAA,IACb,QAAQ;AAAA,IACR,UAAU,CAAC,GAAG,OAAO,CAAC;AAAA,IACtB,qBAAqB;AAAA,IACrB,qBAAqB;AAAA,IACrB,sBAAsB;AAAA,IACtB,kCAAkC;AAAA,IAClC,2BAA2B;AAAA,IAC3B,gBAAgB;AAAA,IAChB,iBAAiB;AAAA,IACjB,0BAA0B;AAAA,IAC1B,aAAa;AAAA,EACf,IAAI;AACJ,QAAM,SAAS,QAAQ,cAAc,CAAC,sBAAsB,YAAY,CAAC;AACzE,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,SAAS;AACb,QAAM,kBAAkB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAChD,QAAM,iBAAiB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAC/C,QAAM,kBAAkB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAChD,QAAM,iBAAiB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAC/C,QAAM,aAAa,SAAS,MAAM,IAAI,GAAW,KAAK,CAAC;AACvD,QAAM,sBAAsB,SAAS,MAAM,oBAAI,IAAI,CAAC;AACpD,QAAM,qBAAqB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAOnD,QAAM;AAAA,IACJ,OAAO;AAAA,IACP,OAAO;AAAA,IACP,KAAK;AAAA,EACP,IAAI,SAAS,MAAM,qBAAqB,MAAM,IAAI,OAAO,MAAM,qBAAqB,OAAO,CAAC,CAAC,CAAC;AAC9F,8BAAU,MAAM;AACd,WAAO,MAAM;AACX,iBAAW,KAAK;AAChB,sBAAgB;AAAA,IAClB;AAAA,EACF,GAAG,CAAC,CAAC;AAGL,8BAAU,MAAM;AACd,eAAW,UAAU,sBAAsB,OAAO;AAClD,eAAW,sBAAsB,sBAAsB;AACvD,eAAW,sBAAsB,kCAAkC;AACnE,eAAW,sBAAsB,2BAA2B;AAC5D,eAAW,sBAAsB,+BAA+B;AAChE,eAAW,sBAAsB,gBAAgB;AACjD,eAAW,sBAAsB,iBAAiB;AAClD,eAAW,sBAAsB,+BAA+B;AAChE,eAAW,aAAa;AACxB,eAAW,sBAAsB,4BAA4B;AAAA,EAC/D,GAAG,CAAC,YAAY,GAAG,SAAS,qBAAqB,iCAAiC,0BAA0B,oBAAoB,eAAe,gBAAgB,oBAAoB,YAAY,uBAAuB,CAAC;AACvN,QAAM,kCAA8B,0BAAY,YAAU;AACxD,QAAI;AACJ,UAAM,WAAW,WAAW,YAAY,MAAM;AAC9C,UAAM,YAAY,eAAe,IAAI,MAAM;AAC3C,UAAM,gBAAgB,eAAe,IAAI,MAAM;AAC/C,UAAM,kBAAkB,aAAa,QAAQ,aAAa,SAAS,UAAU,mBAAmB,SAAS,OAAO,OAAO,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB;AACvL,UAAM,YAAY,oBAAoB,SAAY,WAAW,aAAa,eAAe,IAAI;AAC7F,UAAM,WAAW,aAAa,oBAAoB,SAAY,gBAAgB,IAAI,eAAe,IAAI;AACrG,UAAM,iBAAiB,oBAAoB,SAAY,gBAAgB,IAAI,eAAe,IAAI;AAC9F,UAAM,SAAS;AAAA,MACb,UAAU;AAAA,QACR,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,OAAO;AAAA,MACT;AAAA,MACA,WAAW;AAAA,QACT,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,OAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACL,QAAM,CAAC,aAAa,QAAI,uBAAS;AAAA,IAC/B,eAAe,CAAC;AAAA,IAChB,aAAa;AAAA,EACf,CAAC;AACD,QAAM,WAAO,0BAAY,QAAM;AAC7B,UAAM,QAAQ;AAId,UAAM,mBAAmB,aAAa;AAOtC,UAAM,eAAe,UAAU,MAAM,IAAI,GAAG,GAAG;AAC/C,UAAM,YAAY,WAAS;AAEzB,0BAAoB,QAAQ,cAAY;AACtC,iBAAS,QAAQ,KAAK;AAAA,MACxB,CAAC;AACD,YAAM,WAAW;AACjB,YAAM,KAAK,UAAU;AAGrB,yBAAmB,QAAQ,cAAY;AACrC,iBAAS,QAAQ,KAAK;AAAA,MACxB,CAAC;AAAA,IACH;AACA,QAAI,kBAAkB;AACpB,gBAAU,YAAY;AAAA,IACxB,OAAO;AAGL,oBAAc,eAAe;AAC7B,aAAO,cAAc,eAAe,UAAU;AAG5C,YAAI,aAAa;AACf,wBAAc,gBAAgB,CAAC;AAC/B,gBAAM,iBAAiB,UAAQ;AAC7B,0BAAc,cAAc,KAAK,MAAM,IAAI;AAAA,cACzC,UAAU,KAAK,YAAY;AAAA,cAC3B,UAAU,KAAK,SAAS;AAAA,YAC1B;AAAA,UACF,CAAC;AAAA,QACH;AACA,kBAAU,QAAQ;AAClB,sBAAc,eAAe;AAAA,MAC/B;AAAA,IACF;AACA,UAAM,qBAAqB,oBAAoB,CAAC,eAAe,SAAS,IAAI,cAAc,cAAc;AAGxG,oBAAgB,QAAQ,CAAC,OAAO,WAAW;AACzC,YAAM,YAAY,MAAM,aAAa,MAAM;AAC3C,YAAM,SAAS,gBAAgB,IAAI,MAAM;AACzC,UAAI,WAAW,QAAQ,WAAW,UAAU,OAAO,WAAW,WAAW,QAAQ,WAAW,UAAU,OAAO,QAAQ;AACnH,YAAI,UAAU,WAAW,KAAK,CAAC,MAAM,YAAY;AAC/C,cAAI;AACJ,qBAAW,QAAQ,WAAW,SAAS,UAAU,kBAAkB,OAAO,aAAa,QAAQ,oBAAoB,SAAS,SAAS,gBAAgB,KAAK,MAAM;AAAA,QAClK;AACA,YAAI,CAAC,UAAU,WAAW,KAAK,MAAM,YAAY;AAC/C,cAAI;AACJ,qBAAW,QAAQ,WAAW,SAAS,UAAU,iBAAiB,OAAO,YAAY,QAAQ,mBAAmB,SAAS,SAAS,eAAe,KAAK,MAAM;AAAA,QAC9J;AACA,cAAM,aAAa,UAAU,WAAW;AAAA,MAC1C;AACA,UAAI,CAAC,aAAa,UAAU,WAAW,KAAK,EAAE,qBAAqB,MAAM,WAAW,CAAC,MAAM,WAAW;AACpG;AAAA,MACF;AAGA,UAAI,IAAI,UAAU,YAAY;AAC9B,UAAI,IAAI,UAAU,SAAS;AAC3B,UAAI,gBAAgB,cAAc,cAAc,MAAM;AACtD,UAAI,eAAe;AAEjB,iBAAS,QAAQ,cAAc,UAAU,6BAA6B,cAAc,QAAQ,GAAG,MAAM,KAAK,EAAE,YAAY,MAAM,mBAAmB,EAAE,UAAU,WAAW,WAAW,MAAM;AAGzL,YAAI,MAAM,YAAY,QAAQ;AAC5B,gBAAM,OAAO,SAAS,KAAK,SAAS;AACpC,gBAAM,OAAO,WAAW,KAAK,SAAS;AAAA,QACxC;AAAA,MACF;AAGA,eAAS,QAAQ,GAAG,6BAA6B,CAAC,GAAG,MAAM,KAAK,EAAE,YAAY,MAAM,mBAAmB,EAAE,UAAU,WAAW,WAAW,MAAM;AAC/I,UAAI,MAAM,YAAY,iBAAiB;AACrC,cAAM,UAAU,QAAQ;AAAA,MAC1B,OAAO;AAEL,cAAM,OAAO,SAAS,KAAK,WAAW,kBAAkB;AACxD,cAAM,OAAO,WAAW,MAAM,WAAW,kBAAkB;AAAA,MAC7D;AAAA,IACF,CAAC;AACD,eAAW,qBAAqB,CAAC,SAAS,SAAS,YAAY;AAC7D,YAAM,UAAU,4BAA4B,OAAO;AACnD,YAAM,UAAU,4BAA4B,OAAO;AAGnD,UAAI,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,WAAW,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,SAAS;AAChJ;AAAA,MACF;AACA,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AACxE,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AACxE,UAAI,SAAS;AACX,cAAM,YAAY,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,CAAC,UAAU,YAAY;AACzF,cAAI,uBAAuB,wBAAwB,uBAAuB,wBAAwB,uBAAuB,wBAAwB,uBAAuB;AAExK,WAAC,wBAAwB,QAAQ,UAAU,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YACjV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AACF,WAAC,wBAAwB,QAAQ,UAAU,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YACjV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AAGF,WAAC,wBAAwB,QAAQ,SAAS,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YAChV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AACF,WAAC,wBAAwB,QAAQ,SAAS,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YAChV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AAAA,QACJ,CAAC;AAAA,MACH,OAAO;AACL,YAAI,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB;AAC5K,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC7S,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC7S,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC5S,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAAA,MAC9S;AAGA,UAAI,SAAS;AACX,YAAI,MAAM,iBAAiB,QAAQ,SAAS,QAAQ,QAAQ,SAAS,MAAM,GAAG;AAC5E,cAAI,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB;AAC5K,WAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AACjT,WAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AACjT,WAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAChT,WAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAAA,QAClT;AAAA,MACF,OAAO;AACL,YAAI,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB;AAC5K,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAChT,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAChT,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC/S,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAAA,MACjT;AAAA,IACF,CAAC;AACD,eAAW,wBAAwB,WAAS;AAC1C,UAAI,wBAAwB,yBAAyB,wBAAwB,yBAAyB,wBAAwB,yBAAyB,wBAAwB;AAC/K,YAAM,UAAU,4BAA4B,MAAM,UAAU,CAAC;AAC7D,YAAM,UAAU,4BAA4B,MAAM,UAAU,CAAC;AAG7D,UAAI,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,WAAW,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,SAAS;AAChJ;AAAA,MACF;AACA,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AACxE,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AACxE,OAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACtV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AACF,OAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACtV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AACF,OAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACrV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AACF,OAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACrV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AAAA,IACJ,CAAC;AACD,UAAM,uBAAuB,MAAM;AACjC,iBAAW;AAAA,IACb,CAAC;AAAA,EACH,GAAG,CAAC,QAAQ,UAAU,aAAa,UAAU,CAAC;AAC9C,QAAM,cAAU,sBAAQ,OAAO;AAAA,IAC7B;AAAA,IACA,OAAO;AAAA,IACP,UAAU,WAAS;AACjB,oBAAc,KAAK;AAAA,IACrB;AAAA,IACA,gBAAgB;AAAA,MACd;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV,SAAS;AAAA,IACT;AAAA,EACF,IAAI,CAAC,QAAQ,MAAM,OAAO,WAAW,OAAO,CAAC;AAC7C,QAAM,mBAAe,0BAAY,WAAS;AACxC,QAAI,CAAC,QAAQ;AACX,WAAK,KAAK;AAAA,IACZ;AAAA,EACF,GAAG,CAAC,QAAQ,IAAI,CAAC;AACjB,SAAoB,aAAAA,QAAM,cAAc,cAAc,UAAU;AAAA,IAC9D,OAAO;AAAA,EACT,GAAgB,aAAAA,QAAM,cAAc,gBAAgB;AAAA,IAClD,QAAQ;AAAA,IACR,MAAM;AAAA,IACN;AAAA,EACF,CAAC,GAAG,SAAsB,aAAAA,QAAM,cAAc,OAAO,IAAI,GAAG,QAAQ;AACtE;AAEA,SAAS,WAAW;AAClB,SAAO,WAAW,OAAO,SAAS,OAAO,OAAO,KAAK,IAAI,SAAU,GAAG;AACpE,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAI,IAAI,UAAU,CAAC;AACnB,eAAS,KAAK,EAAG,EAAC,CAAC,GAAG,eAAe,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,IAChE;AACA,WAAO;AAAA,EACT,GAAG,SAAS,MAAM,MAAM,SAAS;AACnC;AAKA,IAAM,wBAAwB,CAAC,UAAU,WAAW,mBAAmB;AACrE,QAAM,UAAM,qBAAO;AACnB,QAAM,kBAAc,0BAAY,MAAM;AACpC,QAAI,CAAC,IAAI,SAAS;AAChB,UAAI,UAAU,SAAS;AAAA,IACzB;AACA,WAAO,IAAI;AAAA,EACb,GAAG,cAAc;AACjB,8BAAU,MAAM;AAEd,UAAM,WAAW,YAAY;AAC7B,UAAM,UAAU,MAAM,UAAU,QAAQ;AACxC,WAAO,MAAM;AACX,cAAQ;AACR,UAAI,UAAU;AAAA,IAChB;AAAA,EACF,GAAG,CAAC,WAAW,CAAC;AAChB,SAAO;AACT;AAMA,IAAM,OAAO,CAAC;AAAA,EACZ;AAAA,EACA;AAAA,EACA;AACF,IAAI;AAAA,EACF,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AACL,MAAM;AACJ,SAAO,IAAI,QAAQ,GAAG,GAAG,CAAC;AAC5B;AAMA,IAAM,OAAO,CAAC;AAAA,EACZ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,IAAI;AAAA,EACF,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AACL,MAAM;AACJ,SAAO,IAAI,WAAW,GAAG,GAAG,GAAG,CAAC;AAClC;AAMA,IAAM,QAAQ,CAAC;AAAA,EACb;AAAA,EACA;AAAA,EACA;AACF,IAAI;AAAA,EACF,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AACL,MAAM;AACJ,SAAO,IAAI,MAAM,GAAG,GAAG,CAAC;AAC1B;AAGA,IAAM,kBAAkB,CAAC,cAAc,eAAe,SAAS;AAC7D,QAAM,eAAW,qBAAO,YAAY;AAGpC,MAAI,gBAAgB,OAAO,iBAAiB,YAAY;AACtD,QAAI,CAAC,aAAa,SAAS;AACzB,mBAAa,UAAU,SAAS;AAAA,IAClC;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAMA,IAAM,kBAA2B,uBAAkB,yBAAW,CAAC,OAAO,iBAAiB;AACrF,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AACd,QAAM,mBAAmB,oBAAoB;AAC7C,QAAM,cAAc,gBAAgB,YAAY;AAChD,QAAM,gBAAY,qBAAO,IAAI;AAG7B,QAAM,qBAAqB,yBAAyB,QAAQ,SAAO,MAAM,QAAQ,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC,IAAI,MAAM,GAAG,CAAC;AAC3H,QAAM,cAAc,sBAAsB,MAAM;AAC9C,UAAM,aAAa,UAAU,QAAQ,cAAc,KAAK,CAAC;AACzD,UAAM,WAAW,0BAA0B,OAAO,OAAO,YAAY,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,YAAY;AACtK,QAAI,OAAO,gBAAgB,YAAY;AACrC,mBAAa,QAAQ;AAAA,IACvB;AACA,gBAAY,UAAU;AACtB,WAAO;AAAA,EACT,GAAG,cAAY;AACb,QAAI,MAAM,YAAY,SAAS,MAAM,GAAG;AACtC,YAAM,eAAe,UAAU,IAAI;AAAA,IACrC;AAAA,EACF,GAAG,CAAC,GAAG,oBAAoB,gBAAgB,CAAC;AAC5C,8BAAU,MAAM;AACd,UAAM,WAAW,YAAY;AAC7B,mBAAe,IAAI,SAAS,QAAQ,oBAAoB,UAAU,UAAU,SAAS,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,IAAI,OAAO,CAAC;AACtL,WAAO,MAAM;AACX,qBAAe,OAAO,SAAS,MAAM;AAAA,IACvC;AAAA,EACF,GAAG,CAAC,WAAW,CAAC;AAChB,QAAM,kBAAc,sBAAQ,MAAM;AAChC,WAAO,eAAe,eAAe,CAAC,GAAG,+BAA+B,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,OAAO,CAAC,GAAG,KAAK;AAAA,EAC/K,GAAG,CAAC,OAAO,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,OAAO,CAAC;AACxG,2BAAyB,aAAa,aAAa,cAAc;AACjE,oBAAkB,aAAa,aAAa,gBAAgB,kCAAkC,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,OAAO,CAAC;AAC3L,SAAoB,aAAAA,QAAM,cAAc,YAAY;AAAA,IAClD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK;AAAA,IACL;AAAA,EACF,GAAG,QAAQ;AACb,CAAC,CAAC;AAKF,IAAM,iBAA8B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACnE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,eAAe,cAAc;AAK7B,IAAM,sBAAmC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EAC1I,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,oBAAoB,cAAc;AAKlC,IAAM,eAA4B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EACnI,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,aAAa,cAAc;AAK3B,IAAM,kBAA+B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EACtI,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,gBAAgB,cAAc;AAK9B,IAAM,sBAAmC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EAC1I,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,oBAAoB,cAAc;AAKlC,IAAM,kBAA+B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EACtI,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,gBAAgB,cAAc;AAK9B,IAAM,eAA4B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EACnI,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,aAAa,cAAc;AAK3B,IAAM,oBAAiC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EACxI,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,kBAAkB,cAAc;AAKhC,IAAM,mBAAgC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EACvI,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,iBAAiB,cAAc;AAK/B,IAAM,wBAAqC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EAC5I,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,iBAAiB,cAAc;AAK/B,IAAM,qBAAkC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAqB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,EACzI,OAAO;AAAA,EACP;AACF,CAAC,CAAC,CAAC;AACH,mBAAmB,cAAc;AAEjC,IAAM,2BAA2B,aAAW;AAC1C,MAAI;AACJ,QAAM,OAAO,yBAAyB,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,SAAS,SAAS;AAClH,QAAM,OAAO,IAAI,GAAc,IAAI;AAGnC,OAAK,YAAY,oBAAoB,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,cAAc,QAAQ,sBAAsB,SAAS,oBAAoB;AACxK,SAAO;AACT;AACA,IAAM,uBAAuB,CAAC;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU,YAAY;AACxB,MAAM;AACJ,SAAO,kBAAkB,MAAM,KAAK;AACpC,QAAM,sBAAsB,OAAO,OAAO,YAAY,MAAM,EAAE,OAAO;AACrE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW,YAAY,YAAY,YAAU;AAC3C,aAAO,OAAO,KAAK,MAAM;AAAA,IAC3B;AAAA,IACA,WAAW,YAAY,YAAY,YAAU,OAAO,KAAK,OAAO,MAAM;AAAA,IACtE,OAAO,cAAc,OAAO,cAAc,MAAM,EAAE,MAAM;AAAA,IACxD,YAAY;AAAA,IACZ,UAAU;AAAA,EACZ;AACF;AACA,IAAM,4BAA4B,CAAC,QAAQ,aAAa,UAAU;AAClE,IAAM,0BAA0B;AAAA,EAC9B,cAAc,CAAC,IAAI,UAAU;AAC3B,OAAG,gBAAgB,OAAO,IAAI;AAAA,EAChC;AAAA,EACA,2BAA2B,IAAI,OAAO;AACpC,OAAG,8BAA8B,KAAK;AAAA,EACxC;AAAA,EACA,eAAe,CAAC,IAAI,UAAU;AAC5B,OAAG,iBAAiB,KAAK;AAAA,EAC3B;AAAA,EACA,gBAAgB,CAAC,IAAI,UAAU;AAC7B,OAAG,kBAAkB,KAAK;AAAA,EAC5B;AAAA,EACA,gBAAgB,CAAC,IAAI,UAAU;AAC7B,OAAG,kBAAkB,KAAK;AAAA,EAC5B;AAAA,EACA,kBAAkB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AACnC,OAAG,oBAAoB,GAAG,GAAG,GAAG,IAAI;AAAA,EACtC;AAAA,EACA,qBAAqB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AACtC,OAAG,uBAAuB,GAAG,GAAG,GAAG,IAAI;AAAA,EACzC;AAAA,EACA,eAAe,CAAC,IAAI,UAAU;AAC5B,OAAG,cAAc,OAAO,IAAI;AAAA,EAC9B;AAAA,EACA,kBAAkB,CAAC,IAAI,UAAU;AAC/B,OAAG,iBAAiB,OAAO,IAAI;AAAA,EACjC;AAAA,EACA,iBAAiB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AAClC,OAAG,UAAU;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,IACF,GAAG,IAAI;AAAA,EACT;AAAA,EACA,gBAAgB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AACjC,OAAG,UAAU;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,IACF,GAAG,IAAI;AAAA,EACT;AAAA,EACA,KAAK,CAAC,IAAI,UAAU;AAClB,OAAG,UAAU,KAAK;AAAA,EACpB;AAAA,EACA,mBAAmB,CAAC,IAAI,UAAU;AAChC,OAAG,qBAAqB,KAAK;AAAA,EAC/B;AAAA,EACA,UAAU,CAAC,IAAI,UAAU;AACvB,OAAG,WAAW;AAAA,EAChB;AAAA,EACA,KAAK,IAAI,OAAO;AACd,OAAG,YAAY,wBAAwB,KAAK,GAAG,IAAI;AAAA,EACrD;AAAA,EACA,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,YAAY,MAAM;AAAA,EAAC;AAAA,EACnB,OAAO,MAAM;AAAA,EAAC;AAChB;AACA,IAAM,6BAA6B,OAAO,KAAK,uBAAuB;AACtE,IAAM,sBAAsB,CAAC,WAAW,SAAS,QAAQ,qBAAqB,SAAS;AACrF,MAAI,CAAC,WAAW;AACd;AAAA,EACF;AACA,QAAM,QAAQ,OAAO,IAAI,UAAU,MAAM;AACzC,MAAI,OAAO;AACT,QAAI,oBAAoB;AACtB,YAAM,OAAO,kBAAkB,MAAM,KAAK;AAC1C,eAAS,KAAK,MAAM,OAAO,WAAW,EAAE,UAAU,WAAW,WAAW,MAAM;AAC9E,gBAAU,eAAe,WAAW,KAAK;AACzC,gBAAU,YAAY,WAAW,KAAK;AAAA,IACxC;AACA,+BAA2B,QAAQ,SAAO;AACxC,UAAI,OAAO,SAAS;AAClB,gCAAwB,GAAG,EAAE,WAAW,QAAQ,GAAG,CAAC;AAAA,MACtD;AAAA,IACF,CAAC;AAAA,EACH;AACF;AACA,IAAM,4BAA4B,CAAC,cAAc,OAAO,QAAQ,qBAAqB,SAAS;AAE5F,QAAM,8BAA0B,sBAAQ,MAAM,2BAA2B,QAAQ,SAAO;AACtF,WAAO,cAAc,MAAM,GAAG,CAAC;AAAA,EACjC,CAAC,GAAG,CAAC,KAAK,CAAC;AACX,8BAAU,MAAM;AACd,UAAM,YAAY,aAAa;AAC/B,wBAAoB,WAAW,OAAO,QAAQ,kBAAkB;AAAA,EAClE,GAAG,uBAAuB;AAC5B;AACA,IAAM,qBAAqB,CAAC,cAAc,OAAO,WAAW;AAC1D,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,8BAAU,MAAM;AACd,UAAM,YAAY,aAAa;AAC/B,WAAO,IAAI,UAAU,QAAQ,aAAa;AAC1C,WAAO,MAAM;AACX,aAAO,OAAO,UAAU,MAAM;AAAA,IAChC;AAAA,EACF,GAAG,CAAC,QAAQ,SAAS,kBAAkB,iBAAiB,qBAAqB,oBAAoB,cAAc,CAAC;AAClH;AAEA,IAAM,cAAc,CAAC,YAAY,QAAQ,YAAY,YAAY,SAAS,cAAc,gBAAgB;AACxG,IAAM,uBAAgC,4BAAc,MAAS;AAC7D,IAAM,sBAAsB,UAAM,yBAAW,gBAAgB;AAK7D,IAAM,gBAAyB,uBAAkB,yBAAW,CAAC,OAAO,iBAAiB;AACnF,QAAM;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,OACJ,cAAc,yBAAyB,OAAO,WAAW;AAC3D,QAAM,gBAAY,qBAAO,IAAI;AAC7B,QAAM,eAAe,gBAAgB,YAAY;AACjD,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AACd,QAAM,oBAAgB,sBAAQ,MAAM;AAClC,WAAO,eAAe,eAAe,eAAe,CAAC,GAAG,cAAc,GAAG,KAAK,GAAG,CAAC,GAAG;AAAA,MACnF,UAAU;AAAA,IACZ,CAAC;AAAA,EACH,GAAG,CAAC,gBAAgB,KAAK,CAAC;AAC1B,QAAM,qBAAqB,0BAA0B,QAAQ,SAAO;AAClE,WAAO,MAAM,QAAQ,cAAc,GAAG,CAAC,IAAI,CAAC,GAAG,cAAc,GAAG,CAAC,IAAI,cAAc,GAAG;AAAA,EACxF,CAAC;AACD,QAAM,qBAAqB,sBAAsB,WAAW,aAAa;AAGzE,QAAM,eAAe,sBAAsB,MAAM;AAC/C,UAAM,OAAO,yBAAyB,aAAa;AACnD,UAAM,YAAY,MAAM,gBAAgB,IAAI;AAC5C,QAAI,OAAO,iBAAiB,YAAY;AACtC,mBAAa,SAAS;AAAA,IACxB;AACA,iBAAa,UAAU;AACvB,WAAO;AAAA,EACT,GAAG,eAAa;AACd,QAAI,MAAM,aAAa,UAAU,MAAM,GAAG;AACxC,YAAM,gBAAgB,SAAS;AAAA,IACjC;AAAA,EACF,GAAG,kBAAkB;AAGrB,8BAAU,MAAM;AACd,UAAM,YAAY,aAAa;AAC/B,UAAM,QAAQ,qBAAqB;AAAA,MACjC;AAAA,MACA,QAAQ,UAAU;AAAA,IACpB,CAAC;AACD,oBAAgB,IAAI,UAAU,QAAQ,MAAM,iBAAiB,MAAM,eAAe,KAAK,IAAI,KAAK;AAChG,WAAO,MAAM;AACX,sBAAgB,OAAO,UAAU,MAAM;AAAA,IACzC;AAAA,EACF,GAAG,CAAC,YAAY,CAAC;AACjB,4BAA0B,cAAc,eAAe,eAAe;AACtE,qBAAmB,cAAc,eAAe,eAAe;AAC/D,QAAM,mBAAe,sBAAQ,MAAM;AACjC,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF,GAAG,CAAC,YAAY,CAAC;AACjB,SAAoB,aAAAA,QAAM,cAAc,iBAAiB,UAAU;AAAA,IACjE,OAAO;AAAA,EACT,GAAgB,aAAAA,QAAM,cAAc,YAAY,SAAS;AAAA,IACvD,KAAK;AAAA,EACP,GAAG,aAAa;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC,GAAG,UAAU,mBAAmB,IAAI,CAAC,eAAe,UAAuB,aAAAA,QAAM,cAAc,aAAa,SAAS;AAAA,IACpH,KAAK;AAAA,EACP,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC;AACF,UAAU,cAAc;AAMxB,IAAM,mBAA4B,mBAAK,WAAS;AAC9C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,aAAS,qBAAO,IAAI;AAC1B,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,oBAAoB;AACxB,QAAM,oBAAgB,sBAAQ,MAAM;AAClC,WAAO,eAAe,eAAe,eAAe,CAAC,GAAG,cAAc,GAAG,OAAO,GAAG,CAAC,GAAG;AAAA,MACrF,UAAU;AAAA,MACV,WAAW;AAAA,IACb,CAAC;AAAA,EACH,GAAG,CAAC,gBAAgB,OAAO,CAAC;AAC5B,QAAM,qBAAqB,sBAAsB,QAAQ,eAAe,KAAK;AAC7E,SAAoB,aAAAA,QAAM,cAAc,YAAY;AAAA,IAClD,KAAK;AAAA,IACL,UAAU;AAAA,MACR,cAAc;AAAA,IAChB;AAAA,EACF,GAAG,UAAU,mBAAmB,IAAI,CAAC,eAAe,UAAuB,aAAAA,QAAM,cAAc,aAAa,SAAS;AAAA,IACnH,KAAK;AAAA,EACP,GAAG,aAAa,CAAC,CAAC,CAAC;AACrB,CAAC;AACD,aAAa,cAAc;AAE3B,IAAM,YAAY,CAAC,YAAY,aAAa,iBAAiB,YAAY,YAAY,cAAc,OAAO;AAC1G,IAAM,2BAAoC,uBAAkB,yBAAW,CAAC,OAAO,iBAAiB;AAC9F,QAAM,iBAAiB,gBAAgB,cAAc,CAAC,CAAC;AACvD,QAAM,gBAAY,qBAAO,IAAI;AAC7B,QAAM,yBAAqB,qBAAO,IAAI;AACtC,QAAM;AAAA;AAAA,IAEF;AAAA,IACA;AAAA,IACA,gBAAgB,CAAC;AAAA;AAAA,IAEjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,EAGF,IAAI,OACJ,iBAAiB,yBAAyB,OAAO,SAAS;AAC5D,QAAM,qBAAqB,sBAAsB,WAAW,eAAe,eAAe,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG;AAAA,IACxG,UAAU;AAAA,EACZ,CAAC,CAAC;AACF,QAAM,mBAAmB,MAAM;AAC7B,UAAM,aAAa,mBAAmB,QAAQ,SAAS,CAAC;AACxD,QAAI,cAAc,qBAAqB,YAAY;AACjD,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACA,8BAAU,MAAM;AACd,UAAM,gBAAgB,iBAAiB;AACvC,QAAI,eAAe;AACjB,oBAAc,eAAe,SAAS,gBAAgB;AAAA,IACxD,OAAO;AACL,cAAQ,KAAK,gFAAgF;AAAA,IAC/F;AAAA,EACF,GAAG,CAAC,CAAC;AAGL,QAAM,sBAAsB,CAAC,OAAO,UAAU;AAC5C,UAAM,gBAAgB,iBAAiB;AACvC,QAAI,eAAe;AACjB,aAAO,eAAe,eAAe,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG;AAAA,QACnD,WAAW,YAAU;AACnB,wBAAc,YAAY,OAAO,MAAM;AACvC,iBAAO;AAAA,QACT;AAAA,QACA,WAAW,YAAU;AACnB,wBAAc,YAAY,OAAO,MAAM;AACvC,wBAAc,eAAe,cAAc;AAAA,QAC7C;AAAA,QACA,UAAU;AAAA,MACZ,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AACA,SAAoB,aAAAA,QAAM,cAAc,YAAY,SAAS;AAAA,IAC3D,KAAK;AAAA,EACP,GAAG,gBAAgB;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC,GAAgB,aAAAA,QAAM,cAAc,YAAY;AAAA,IAC/C,KAAK;AAAA,EACP,GAAG,QAAQ,GAAG,cAAc,QAAQ,cAAc,SAAS,SAAS,UAAU,IAAI,CAAC,UAAU,UAAuB,aAAAA,QAAM,cAAc,WAAW,SAAS,CAAC,GAAG,gBAAgB,UAAU;AAAA,IACxL,KAAK,UAAQ,eAAe,QAAQ,KAAK,IAAI;AAAA,IAC7C,gBAAgB,WAAS,oBAAoB,OAAO,KAAK;AAAA,EAC3D,CAAC,GAAgB,aAAAA,QAAM,cAAc,aAAAA,QAAM,UAAU,MAAM,cAAc,IAAI,CAAC,MAAMC,WAAuB,aAAAD,QAAM,cAAc,uBAAU;AAAA,IACvI,KAAKC;AAAA,EACP,GAAG,IAAI,CAAC,GAAG,mBAAmB,IAAI,CAAC,eAAe,kBAA+B,aAAAD,QAAM,cAAc,aAAa,SAAS;AAAA,IACzH,KAAK;AAAA,EACP,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC;AACF,qBAAqB,cAAc;AAKnC,IAAM,kBAAkB,CAAC,OAAO,OAAO,WAAW;AAChD,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,eAAW,qBAAO;AACxB,wBAAsB,MAAM;AAC1B,QAAI,MAAM,WAAW,MAAM,SAAS;AAClC,YAAM,WAAW,MAAM,mBAAmB,QAAQ,MAAM,SAAS,MAAM,SAAS,IAAI;AACpF,eAAS,UAAU;AACnB,aAAO;AAAA,IACT;AAAA,EACF,GAAG,WAAS;AACV,QAAI,OAAO;AACT,eAAS,UAAU;AACnB,UAAI,MAAM,gBAAgB,MAAM,MAAM,GAAG;AACvC,cAAM,mBAAmB,OAAO,IAAI;AAAA,MACtC;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AACL,SAAO;AACT;AASA,IAAM,gBAAgB,CAAC,OAAO,OAAO,CAAC,aAAa,iBAAiB,aAAa,eAAe,MAAM;AACpG,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,SAAO,gBAAgB,OAAO,OAAO,OAAO,UAAU,MAAM,sBAAsB,WAAW,GAAG,6BAA6B,eAAe,GAAG,sBAAsB,WAAW,GAAG,6BAA6B,eAAe,CAAC,CAAC;AACnO;AAUA,IAAM,oBAAoB,CAAC,OAAO,OAAO,CAAC,aAAa,WAAW,MAAM;AACtE,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,SAAO,gBAAgB,OAAO,OAAO,OAAO,UAAU,UAAU,sBAAsB,WAAW,GAAG,sBAAsB,WAAW,CAAC,CAAC;AACzI;AASA,IAAM,mBAAmB,CAAC,OAAO,OAAO,CAAC,aAAa,aAAa,MAAM,MAAM,MAAM;AACnF,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,SAAS,OAAO,UAAU,SAAS,sBAAsB,WAAW,GAAG,sBAAsB,WAAW,GAAG,sBAAsB,IAAI,CAAC;AAC5I,MAAI,QAAQ;AACV,WAAO,gBAAgB;AACvB,WAAO,SAAS;AAAA,EAClB;AACA,SAAO,gBAAgB,OAAO,OAAO,MAAM;AAC7C;AASA,IAAM,oBAAoB,CAAC,OAAO,OAAO,CAAC,aAAa,aAAa,MAAM,MAAM,MAAM;AACpF,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,SAAS,OAAO,UAAU,UAAU,sBAAsB,WAAW,GAAG,sBAAsB,WAAW,GAAG,sBAAsB,IAAI,CAAC;AAC7I,MAAI,QAAQ;AACV,WAAO,gBAAgB;AACvB,WAAO,SAAS;AAAA,EAClB;AACA,SAAO,gBAAgB,OAAO,OAAO,MAAM;AAC7C;AAMA,IAAM,eAAe,CAAC,OAAO,OAAO,CAAC,aAAa,aAAa,MAAM,MAAM;AACzE,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,eAAe,sBAAsB,WAAW;AACtD,QAAM,eAAe,sBAAsB,WAAW;AACtD,QAAM,SAAS,OAAO,UAAU,KAAK,QAAQ,cAAc,YAAY;AACvE,SAAO,gBAAgB,OAAO,OAAO,MAAM;AAC7C;AAMA,IAAM,iBAAiB,CAAC,OAAO,OAAO,CAAC,aAAa,aAAa,YAAY,WAAW,OAAO,MAAM;AACnG,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,eAAe,sBAAsB,WAAW;AACtD,QAAM,eAAe,sBAAsB,WAAW;AACtD,QAAM,SAAS,OAAO,UAAU,OAAO,YAAY,WAAW,SAAS,cAAc,YAAY;AACjG,SAAO,gBAAgB,OAAO,OAAO,MAAM;AAC7C;AAkCA,IAAM,oBAAoB,CAAC,aAAa,aAAa,QAAQ,WAAW,KAAK,OAAO,YAAY,SAAY,QAAQ,OAAO,IAAI;AAC/H,IAAM,UAAU,YAAU,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,UAAU,MAAM,KAAK,OAAO,CAAC;",
  "names": ["r", "React", "index"]
}
